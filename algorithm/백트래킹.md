# 백트래킹 (Backtracking)

## 1. 백트래킹이란?

> **모든 경우의 수를 탐색**하되,
> “해답이 될 수 없는 경우는 조기에 포기(가지치기)”하는 탐색 알고리즘.

즉, **DFS(깊이 우선 탐색)** 기반의 완전탐색이지만
**조건을 만족하지 않으면 탐색을 멈추고 되돌아간다(backtrack)**는 점이 핵심이다.

---

## 2. 기본 아이디어

1. **결정(Decision):** 현재 단계에서 가능한 선택을 하나 고른다.
2. **검사(Pruning):** 그 선택이 유효한지 확인한다.
3. **진행(Recursion):** 유효하면 다음 단계로 재귀 호출한다.
4. **되돌리기(Backtrack):** 더 진행할 수 없거나 조건을 만족하면 돌아간다.

이 과정을 반복하면서 **모든 유효한 조합, 순열, 상태**를 탐색한다.

---

## 3. 기본 템플릿

```java
void backtrack(상태 state) {
    if (해결됨(state)) {
        결과 저장;
        return;
    }

    for (선택 in 가능한 후보들) {
        if (유망한가(선택)) {       // 가지치기
            선택 적용(state);
            backtrack(다음 상태);
            선택 취소(state);        // 되돌리기
        }
    }
}
```

> 핵심 패턴: `선택 → 재귀 → 선택 취소`

---

## 4. 예제별 정리

### (1) N-Queen 문제

* 목표: N×N 체스판 위에 N개의 퀸을 서로 공격하지 않게 놓기
* 핵심: 같은 열, 대각선에 위치하면 안 된다 → `isSafe`로 가지치기

```java
static void solve(int row) {
    if (row == N) {
        count++;
        return;
    }
    for (int col = 0; col < N; col++) {
        if (isSafe(row, col)) {
            board[row] = col;
            solve(row + 1);
        }
    }
}
```

* `isSafe`:

    * 같은 열 검사 → `board[i] == col`
    * 대각선 검사 → `|board[i]-col| == |row-i|`
* 시간복잡도: 최악 `O(N!)`, 하지만 가지치기로 탐색 공간이 많이 줄어듦.

---

### (2) 조합 (Combination)

* 목표: N개 중 R개를 고르는 모든 조합 구하기
* 중복 없는 조합 → 다음 단계에서는 `i+1`부터 탐색

```java
static void combination(int index, int depth, List<Integer> current) {
    if (depth == R) {
        result.add(new ArrayList<>(current));
        return;
    }

    for (int i = index; i < N; i++) {
        current.add(arr[i]);
        combination(i + 1, depth + 1, current);
        current.remove(current.size() - 1);
    }
}
```

* 시간복잡도: `O(nCr × R)`
* 예시 결과 (N=4, R=2): `[1,2], [1,3], [1,4], [2,3], [2,4], [3,4]`

---

### (3) 중복 조합 (Combination with Repetition)

* 같은 원소 여러 번 선택 가능
* 차이점: **`solution(i, …)` → 자기 자신을 다시 선택 가능**

```java
static void combWithDup(int index, int depth, List<Integer> current) {
    if (depth == R) {
        result.add(new ArrayList<>(current));
        return;
    }

    for (int i = index; i < N; i++) {
        current.add(arr[i]);
        combWithDup(i, depth + 1, current); // i 그대로 유지
        current.remove(current.size() - 1);
    }
}
```

* 시간복잡도: `O(nHr × R)`
  (`nHr = (n+r-1)! / (r!(n-1)!)`)
* 예시 (N=3, R=2): `[1,1], [1,2], [1,3], [2,2], [2,3], [3,3]`

---

### (4) 부분집합 (Subset)

* 각 원소를 **포함할지 / 안할지** 두 가지로 나뉨 → 전체 경우의 수 `2^N`

```java
static void subset(int index, List<Integer> current) {
    if (index == arr.length) {
        result.add(new ArrayList<>(current));
        return;
    }

    // 선택
    current.add(arr[index]);
    subset(index + 1, current);

    // 미선택
    current.remove(current.size() - 1);
    subset(index + 1, current);
}
```

* 시간복잡도: `O(2^N × N)`
* 예시: `[1,2,3]` → `[1,2,3], [1,2], [1,3], [1], [2,3], [2], [3], []`

---

## 5. 시간복잡도 요약

| 유형      | 탐색 수식      | 근사 복잡도     | 비고            |
| ------- | ---------- | ---------- | ------------- |
| N-Queen | 약 O(N!)    | 매우 큼       | 제약 조건 많을수록 감소 |
| 조합      | nCr        | O(nCr × R) | r 고정          |
| 중복 조합   | nHr        | O(nHr × R) | 같은 원소 가능      |
| 부분집합    | ∑nCr = 2^N | O(2^N × N) | 모든 크기의 조합 탐색  |

---

## 6. 백트래킹과 DFS의 차이

| 구분    | DFS    | 백트래킹                    |
| ----- | ------ | ----------------------- |
| 목적    | 경로 탐색  | 모든 경우 탐색                |
| 가지치기  | 없음     | 있음 (조건 기반 중단)           |
| 대표 예시 | 그래프 탐색 | N-Queen, 조합, 순열, Sudoku |

---

## 7. 백트래킹 사고 정리

1. **결정해야 하는 “자리(depth)”** 를 먼저 생각한다.
2. 각 자리에서 “가능한 후보”를 만든다.
3. 후보를 선택하고 다음 단계로 재귀 호출한다.
4. 돌아왔을 때는 반드시 “되돌리기(remove)” 한다.
5. 필요하다면 “유망하지 않은 가지는 더 이상 진행하지 않는다.”