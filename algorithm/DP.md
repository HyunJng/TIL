# DP (Dynamic Programming)

## 1. DP란 무엇인가?

* 큰 문제를 작은 문제로 나눠 푸는 알고리즘 기법.
* **중복 계산**이 많은 문제에서 이미 계산한 결과를 저장해두고 재사용 → 시간 복잡도 절감.
* 분할 정복과 달리 **부분 문제들이 겹치는 경우**에 적합.

---

## 2. DP 적용 조건

1. **최적 부분 구조 (Optimal Substructure)**

    * 큰 문제의 최적해가 작은 문제의 최적해로부터 만들어진다.
    * 예: 최단 경로, 피보나치 수열

2. **중복되는 부분 문제 (Overlapping Subproblems)**

    * 동일한 하위 문제가 여러 번 등장한다.
    * 예: 피보나치에서 F(3), F(2)는 여러 번 계산됨

---

## 3. 접근 방식

* **Top-Down (재귀 + 메모이제이션)**

    * 재귀적으로 문제를 풀되, 계산 결과를 캐시에 저장해두고 필요 시 재사용.
    * 구현은 직관적이지만 재귀 깊이에 의한 스택 오버플로우 가능성 존재.

* **Bottom-Up (반복문 + 테이블 채우기)**

    * 가장 작은 문제부터 시작해 점진적으로 큰 문제의 해를 채워감.
    * 보통 더 효율적이고 메모리 관리도 용이.

---

## 4. 자주 등장하는 문제 유형

* **피보나치 수열** → DP 입문 문제
* **계단 오르기 / 타일 채우기** → 점화식 활용
* **최장 증가 부분 수열 (LIS)** → N² DP 또는 N log N 이분 탐색
* **배낭 문제 (Knapsack Problem)** → 고전적인 DP 문제
* **최단 경로 (플로이드-워셜, 다익스트라 변형)**
* **동전 교환 (Coin Change)**, **편집 거리 (Edit Distance)**

---

## 5. 예시 코드 (계단 오르기 - Bottom-Up)

```java
public static int climbStairs(int n) {
    if (n <= 2) return n;

    int[] dp = new int[n + 1];
    dp[1] = 1; dp[2] = 2;

    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

* 점화식: `f(n) = f(n-1) + f(n-2)`
* 작은 문제(`f(1), f(2)`)부터 채워가며 큰 문제(`f(n)`) 해결

---

## 6. 핵심 정리

* DP는 **반복되는 계산을 줄여 효율적으로 최적해를 구하는 방법**이다.
* 문제를 만나면 먼저 "부분 문제로 쪼갤 수 있는가?" → "중복되는 계산이 있는가?"를 확인.
* 구현할 때는 **점화식 세우기**가 가장 중요하다.