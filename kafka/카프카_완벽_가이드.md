> 인프런 강의 '카프카 완벽 가이드' 수강 후 정리

## Topic 이란?
* 토픽은 partition으로 구성된 일렬의 로그 파일
    * RDBMS의 Table과 유사한 기능
    * Topic은 key와 value 기반의 메시지 구조.
    * value로는 어떤 타이의 메시지도 가능(문자열, 객체, 숫자값 등)
    * 로그 파일과 같이 연속적으로 발생하는 데이터를 저장하는 구조
    * 데이터는 append만 됨. 한번 들어가면 update 불가. 즉 **순차적**임. 

## Topic 과 Partition
![카프카완벽가이드_1.png](/kafka/images/%EC%B9%B4%ED%94%84%EC%B9%B4%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C_1.png)
* 토픽은 1개 이상의 파티션을 가질 수 있음
* 토픽의 파티션의 Kafka의 병렬 기능과 가용성 기능의 핵심 요소.

## Broker
* 피지컬적인 서버 하나

## Topic 과 Partition 과 Offset
* 개별 파티션은 정렬되고, 변경할 수 없는 일렬의 레코드로 구성된 로그 메시지.
* 개별 레코드는 offset으로 불리는 일렬의 번호를 할당받음
* 개별 파티션은 다른 파티션과 완전히 독립적임
* 개별 파티션 내에서 정렬되고 offset이 할당됨.

## Topic 과 Partition의 병렬 분산 처리
![카프카완벽가이드_2.png](/kafka/images%2F%EC%B9%B4%ED%94%84%EC%B9%B4%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C_2.png)
* producer은 여러 partition으로 보낼 수 있고
* consumer도 여러 partition에서 가져올 수 있음

![카프카완벽가이드_3.png](/kafka/images%2F%EC%B9%B4%ED%94%84%EC%B9%B4%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C_3.png)
* 여러 카프카 브로커들에 분산 저장될 수 있음
* Broker 각각은 IP가 다른 서버임. 서로 연결된 무언가가 있긴 함.

## Cluster에서의 가용성
![카프카완벽가이드_4.png](/kafka/images%2F%EC%B9%B4%ED%94%84%EC%B9%B4%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C_4.png)
* 하나가 내려가면 메시지가 유실되기에 가용성이 매우 중요.
* replication-factor을 지정하면 복제 영역에 서로의 메시지 상태를 복제하여 가지고 있게 됨.

---

## Producer 과 Consumer 개요
### Producer
* Producer은 Topic에 메시지를 보냄
* Producer은 Partitioner를 통해 성능/로드밸런싱/가용성/업무정합성 등을 고려하여 
  어떤 브로커의 파티션으로 메시지를 보낼지 전략적으로 결정
* 메시지 = ProducerRecord
  * **Topic**: 어디로 갈지
  * Partition: 어디로 갈지 2
  * Key-**Value**: 데이터
  * Header: 추가적 속성(ex. timestamp)

### Consumer
* Consumer은 Topic에서 메시지를 읽어들임
* 여러개의 Consumer들로 구성될 경우 
  어떤 브로커 파티션에서 메시지를 읽어들일지 전략적으로 결정

## Consumer의 `auto.offset.reset`
* Consumer이 Topic에 처음 접속하여 Message를 가져올 때 가장 오래된 처음 offset부터(earliest) 가져올 것인지, 
  가장 최근인 마지막 offset 부터(latest) 가져올 것인지 설정한는 파라미터.
* default는 latest이다.
  * `auto.offset.reset=earliest` : 처음 offset 부터 읽음
  * `auto.offset.reset=latest` : 마지막 offset 부터 읽음

## Producer과 Consumer 간의 Serialized Message 전송
![카프카완벽가이드_5.png](/kafka/images%2F%EC%B9%B4%ED%94%84%EC%B9%B4%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C_5.png)
* Broker의 Partition에 저장된 데이터 형태는 Byte Array이다.
* 따라서 Producer에서 데이터는 Serialized 되어야한다.
* Consumer은 역직렬화해서 데이터를 객체 형태로 사용한다.
* Java에서 기본타입 Serializer을 제공해주고 있지만 Object를 사용할땐 Serialize를 구현해주어야한다. 

---
## Key 값을 가지는/가지지않는 메시지의 순서 보장 여부
* Topic이 여러 개의 파티션을 가질 때 메시지의 전송 순서가 보장되지 않은 채로 Consumer에서 읽혀질 수 있음
  * 카프카는 하나의 파티션 내에서만 메시지 순서를 보장함
* 다만 **key값을 가지는 메시지라면 특정 파티션으로 고정되어 전송할 수 있음**
  * 하나의 파티션에만 메시지가 들어갈 수 있다면 순서 보장을 할 수 있음

## 파티션 분배 전략
### Key가 없는 메시지인 경우
* **라운드로빈(RR)**
  * kafka 2.4버전 이전 기본 파티션 분배 전략
  *  메시지를 파티션에 균일하게 분배하려는 전략으로 **메시지 배치를 순차적으로 다른 파티션으로 전송**
  * 메시지가 배치 데이터를 빨리 채우지 못하면서 전송이 늦어지거나 배치를 다 채우지 못하고 전송하게 되어 성능 문제 발생
  ![카프카완벽가이드_6.png](/kafka/images%2F%EC%B9%B4%ED%94%84%EC%B9%B4%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C_6.png)
* **스티키 파티셔닝(Sticky Partitioning)**
  * kafka 2.4.버전부터 기본 파티션 분배 전략
  * 하나의 배치에 메시지를 빠르게 먼저 채워서 보내는 방식
  ![카프카완벽가이드_7.png](/kafka/images%2F%EC%B9%B4%ED%94%84%EC%B9%B4%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C_7.png)

---
## Consumer Group 과 Consumer
* 모든 Consumer들은 단 하나의 Consumer Group에 소속되어야한다.
* 파티션 레코드들은 Grooup안에선 단 하나의 Consumer에만 할당된다.

![카프카완벽가이드_8.png](/kafka/images%2F%EC%B9%B4%ED%94%84%EC%B9%B4%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C_8.png)
* 보통 partition의 개수와 Consumer의 개수를 동일하게 두고 사용함(병렬처리 하기 위함)
* Consumer Group 내에 Consumer 변화가 있을 때마다 파티션과 Consumer의 조합을 변경하는 Rebalancingg이 발생한다. 

![카프카완벽가이드_9.png](/kafka/images%2F%EC%B9%B4%ED%94%84%EC%B9%B4%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C_9.png)
* Consumer Group이 다른 컨슈머는 아예 별개로 본다.

----
## Producer 뜯어보기
### 1. `send()`
![카프카완벽가이드_10.png](/kafka/images/%EC%B9%B4%ED%94%84%EC%B9%B4%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C_10.png)
* main Thread에서 분리된 **비동기** Thread를 통해 카프카로 메시지 전송.
* main Thread에서 Serialize 하고 별도 Thread에 넘겨줌

### 2. Producer과 브로커와의 메시지 동기화
![카프카완벽가이드_11.png](/kafka/images/%EC%B9%B4%ED%94%84%EC%B9%B4%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C_11.png)
#### 2.1. Sync(동기)
* Producer는 브로커로부터 해당 메시지를 성공적으로 받았다는 Ack 메시지를 받은 후 
  다음 메시지를 전송
* `KafkaProducer.send().get()`을 호출하여 브로커로부터 Ack 메시지를 받을 떄까지 대기(Weit)함

#### 2.2. Async(비동기)
![카프카완벽가이드_12.png](/kafka/images/%EC%B9%B4%ED%94%84%EC%B9%B4%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C_12.png)
* Producer는 브로커로부터 해당 메시지를 성공적으로 받았다는 Ack 메시지를 기다리지 않고 전송
* 브로커로부터 Ack 메시지를 비동기로 Producer에 받기 위해서 Callback을 적용함
* `send()` 메소드 호출 시에 callback 객체를 인자로 입력하여 Ack메시지를 Producer로 전달할 수 있음.
  ```java
    kafkaProducer.send(producerRecord, new Callback (){
    @Override
    public void onCompletion(RecordMetadata recordMetadata, Exception e) {
        // Send-Network-Thread가 Callback 호출 
    }
  });
  ```
> Retry Exception이 발생하면 Sync/Async 상관없이 Send-Network-Thread가 재전송할 수 있음

> 동기(Sync)보다는 비동기(Async)를 더 많이 사용함. 

## Producer의 acks 설정에 따른 send 방식
* Producer는 해당 Topic의 Partition의 Leader Broker에게만 메시지를 보낸다
  * 그 후 Leader은 다른 Broker에게 메시지를 전달하여 복제해둔다.
* acks 설정에 따라 Leader Broker이 Producer에게 acks를 언제 보낼지 결정할 수 있다. 

### `acks=0`
* Producer는 Leader broke가 메시지 A를 정상적으로 받았는지에 대한 Ack 메시지를 받지 않고 다음 메시지인 메시지 B를 바로 전송
  * 따라서 재전송 기준이 없어져서 Broker에 기록되지않아도 재전송X
* 메시지 손실의 우려가 가장 크지만 가장 빠르게 전송할 수 있다
  * IOT 센서 데이터등 데이터의 손실에 민감하지 않은 데이터 전송에 활용됨

### `acks=1`
* Producer는 Leader broke가 메시지 A를 정상적으로 받았는지에 대한 Ack 메시지를 받은 후 다음 메시지인 메시지 B를 바로 전송
* 만약 Leader가 메시지를 복제 중에 다운될 경우 다음 Leader가 될 브로커에는 메시지가 없을 수 있기 때문에 메시지를 소실할 우려가 있음.

### `acks=all`(default)
* Producer는 Leader broke가 메시지 A를 정상적으로 받은 뒤 
  min.insync.replicas 개수 만큼의 Replicator에 복제를 수행한 뒤에 보내는 Ack 메시지를 받은후 다음 메시지인 메시지 B를 바로 전송
  * `min.insync.replicas=2`: 복제가 2개까지 살아있을 때 acks를 정상적으로 응답함
* 만약 오류 메시지를 브로커로부터 받으면 메시지 A를 재전송
* 메시지 손실이 되지 않도록 모든 장애 상황을 감안한 전송 모드이지만 Ack를 오래 기다려야 하므로 상대적으로 전송속도가 느림

> Callback 기반의 async에서도 동일하게 acks 설정에 기반하여 retry가 수행됨

> Sync 방식에서 `acks=0`인 경우 의미가 없어서 절대 하지 말것.

---
## Producer의 메시지 배치 전송의 이해
### Record Accumulator → Send Thread 관련 
![카프카완벽가이드_13.png](/kafka/images/%EC%B9%B4%ED%94%84%EC%B9%B4%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C_13.png)
* Producer에서 `send()`를 실행하면 Record Accumulator에 적재하고 바로 반환(본질적으로 비동기)
  * `producer.send().get()`하면 Sender Thread가 응답 보낼 때까지 기다리는 것
* Sender Thread는 Record Accumulator에 누적된 메시지 배치를 꺼내서 브로커로 전송함
  * `buffer.memory` : Record Accumulator의 전체 메모리 사이즈
  * `batch.size`: 단일 배치의 사이즈
  * `liger.ms`: sender thread로 메시지를 보내기 전 배치로 메시지를 만들어서 보내기 위한 최대 대기 시간
* Record Accumulator에서 별도의 Sender Thread로 배치단위로 전송
  * `max.inflight.requests.per.connection`: Accumulator에서 Sender Thread에 보낼 수 있는 최대 배치 개수

> * `linger.ms`
>   * 반드시 0보다 크게 설정할 필요 없음. 이건 배치사이즈보다 더 보내고 싶을 떄 쓰는건데 이미 빠르면 굳이.
>   * 20ms이하로 설정 권장

> `RecordMetaData recordMetadata = KafkaProducer.send().get()` 와 같은 방식으로 개별 메시지 
> 별로 응답을 받을 때까지 block이 되는 방식으로는 메시지 배치 처리가 불가. 전송은 배치레벨이지만 배치에 메시지는 단 1개

### Send Thread → Broker 관련
* `max.inflight.requests.per.connection`
  * 비동기여도 무작정 Sender Thread가 Broker에게 계속 메시지를 보내는게 아니다
  * `max.inflight.requests.per.connection` 개수의 배치만큼 전송하고 Ack 신호를 기다린다
  * 즉, 브로커 서버의 응답없이 Producer의 sender thread가 한번에 보낼 수 있는 메시지 배치의 개수. Default 값은 5 
  * Kafka Producer의 메시지 전송 단위는 Batch임
  * 1-5 사이로 설정 가능

---
## Producer의 메시지 전송/재전송 시간 파라미터
### 관련 파라미터
* `max.block.ms`: Send( ) 호출 시 Record Accumulator에 입력하지 못하고 block되는 최대 시간. 초과 시 Timeout Exception
* `linger.ms`: Sender Thread가 Record Accumulator에서 배치별로 가져가기 위한 최대 대기시간
* `request.timeout.ms`: 전송에 걸리는 최대시간. 전송 재시도 대기시간 제외. 초과시 retry하거나 Timeout Exception
* `delivery.timeout.ms`: Producer 메시지(배치) 전송에 허용된 최대시간 초과시 Timeout Exception
* `retry.backoff.ms`: 재전송 전 대기 시간.

> delivery.timeout.ms >= linger.ms + request.timeout.ms (버전별로 다를 수 있음)

### 오류 상황
#### Record Accumulator
* 만약 send()를 했는데 Record Accumulator이 꽉 찼다면?
* max.block.ms만큼 기다리다가 초과하면 Timeout Exception

#### Sender Thread
* 보냈는데 Error 또는 응답없다면?
* request.timeout.ms만큼 기다리고
* 기다렸는데 답이 없거나 Error이 오면 재전송

> * 재전송은 retries와 delivery.timeout.ms로 조절한다
> * 보통 retries는 무한대로 설정하고 delivery.timeout.ms(기본 2분)으로 조절

---

## Producer 메시지 전송 순서와 Broker 메시지 저장 순서
* 분산 시스템은 반드시 재전송이 되어야하기 때문에
* 재전송때문에 Producer에서 메시지 전송한 순서와 Broker에 저장된 메시지 순서가 다를 수 있다.
  * B0, B1로 보냈는데 B1, B0 순으로 저장
* 따라서 순서가 중요하다면 비즈니스 로직에서 순서를 제어할 수 있는 것이 꼭 필요.
* 카프카도 `enable.idempotence=true`로 이슈 대처를 해주긴 함. 

---
## 재전송 관련 용어 정리
* 최대 한번 전송(at most once) : acks=0, 메시지 소실 가능성 O
* 적어도 한번 전송(at least once): 중복 허용. retry > 0. acks=1,all
* 정확히 한번 전송(exactly once):
  * Transaction 기반 전송: Consumer → process → Producer(주로 Kafka streams)에 주로 사용되는 처리
  * Transaction 기반 전송은 중복 없이(멱등성) 전송된다
    * Producer의 메시지 전송 retry 시 중복 제거  

---
## Idempotence(멱등성) 기반 중복없이 전송방법
* Producer는 Producer ID와 메시지 Sequence를 Header에 저장하여 전송
  * 메시지 Sequence는 메시지의 고유 Sequence번호. 0부터 시작하여 순차적으로 증가.(메시지는 배치 단위) 
  * Producer ID는 Producer가 기동시마다 새롭게 생성
* 브로커에서 메시지 Sequece가 중복 될 경우 이를 메시지 로그에 기록하지 않고 Ack만 전송.
* 브로커는 Producer가 보낸 메시지의 Sequence가 브로커가 가지고 있는 메시지의 Sequence보다 1만큼 큰 경우에만 브로커에 저장
* Idempotence 적용 후 성능이 약간 감소(최대 20%)할 수 있지만 기본적으로 idempotence 적용을 권장
* 
### Idempotence 을 위한 Producer 설정방법
* enable.idempotence = true 
* acks = all 
* retries는 0 보다 큰 값 
* max.in.flight.requests.per.connection은 1에서 5사이 값

> kafka 3.0 버전부터는 기본설정이 `enable.idempotence=true`이지만
> 명시적으로 이를 설정해주지 않을 시, 다른 파라미터 설정과 충돌났을 때 idempotence로 동작하지 않는다
> **따라서 명시적으로 `enable.idempotence=true` 해주자**

> +) 배치내의 개별 메시지만 토픽에 write되지는 않음. 배치단위로 write

### Idempotence 기반으로 메시지 전송 순서 확인해보기
1. max.in.flight.requests.per.connection 만큼 여러 개의 배치들이 Broker에 전송
2. Broker는 메시지 배치를 처리시 write된 배치의 마지막 메시지 Sequence + 1 이 아닌 배치 메시지가 올 경우
   OutOfOrderSequenceException을 생성하여 Producer에 오류로 전달. 
```
  * max.in.flight가 3 이고 B0,B1,B2 전송
  * B0은 write 성공, B1 write 중 실패
  * B2는 B0의 맨 마지막 seq + 1보다 seq가 큰 상태라 OutOfOrderSequenceException 발생 
```

### Idempotence 사용 시 주의할점
* Producer와 Broker간에 메시지 **retry 시**에만 중복 제거를 수행하는 메커니즘이다.
  * 동일한 메시지를 `send()`해도 중복제거되지 않는다.
* Producer가 재 기동되면 Producer ID가 달라지므로 이전 Producer가 전송한 메시지를 중복해서 보낼 수 있다.
* (이해못했지만 일단 씀) Consumer -> Process -> Producer 로직에서 Consumer가 __consumer_offsets 에 읽은 offset을 저장하지
  못하였지만 Producer는 메시지를 전송하였다면, Consumer는 이전 offset을 읽어서 Producer를 통해
  중복된 메시지를 전송할 수 있음. Transaction 기반 처리 필요

---
