> 인프런 강의 '카프카 완벽 가이드' 수강 후 정리

## Topic 이란?
* 토픽은 partition으로 구성된 일렬의 로그 파일
    * RDBMS의 Table과 유사한 기능
    * Topic은 key와 value 기반의 메시지 구조.
    * value로는 어떤 타이의 메시지도 가능(문자열, 객체, 숫자값 등)
    * 로그 파일과 같이 연속적으로 발생하는 데이터를 저장하는 구조
    * 데이터는 append만 됨. 한번 들어가면 update 불가. 즉 **순차적**임. 

## Topic 과 Partition
![카프카완벽가이드_1.png](/kafka/images/%EC%B9%B4%ED%94%84%EC%B9%B4%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C_1.png)
* 토픽은 1개 이상의 파티션을 가질 수 있음
* 토픽의 파티션의 Kafka의 병렬 기능과 가용성 기능의 핵심 요소.

## Broker
* 피지컬적인 서버 하나

## Topic 과 Partition 과 Offset
* 개별 파티션은 정렬되고, 변경할 수 없는 일렬의 레코드로 구성된 로그 메시지.
* 개별 레코드는 offset으로 불리는 일렬의 번호를 할당받음
* 개별 파티션은 다른 파티션과 완전히 독립적임
* 개별 파티션 내에서 정렬되고 offset이 할당됨.

## Topic 과 Partition의 병렬 분산 처리
![카프카완벽가이드_2.png](/kafka/images%2F%EC%B9%B4%ED%94%84%EC%B9%B4%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C_2.png)
* producer은 여러 partition으로 보낼 수 있고
* consumer도 여러 partition에서 가져올 수 있음

![카프카완벽가이드_3.png](/kafka/images%2F%EC%B9%B4%ED%94%84%EC%B9%B4%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C_3.png)
* 여러 카프카 브로커들에 분산 저장될 수 있음
* Broker 각각은 IP가 다른 서버임. 서로 연결된 무언가가 있긴 함.

## Cluster에서의 가용성
![카프카완벽가이드_4.png](/kafka/images%2F%EC%B9%B4%ED%94%84%EC%B9%B4%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C_4.png)
* 하나가 내려가면 메시지가 유실되기에 가용성이 매우 중요.
* replication-factor을 지정하면 복제 영역에 서로의 메시지 상태를 복제하여 가지고 있게 됨.

---

## Producer 과 Consumer 개요
### Producer
* Producer은 Topic에 메시지를 보냄
* Producer은 Partitioner를 통해 성능/로드밸런싱/가용성/업무정합성 등을 고려하여 
  어떤 브로커의 파티션으로 메시지를 보낼지 전략적으로 결정
* 메시지 = ProducerRecord
  * **Topic**: 어디로 갈지
  * Partition: 어디로 갈지 2
  * Key-**Value**: 데이터
  * Header: 추가적 속성(ex. timestamp)

### Consumer
* Consumer은 Topic에서 메시지를 읽어들임
* 여러개의 Consumer들로 구성될 경우 
  어떤 브로커 파티션에서 메시지를 읽어들일지 전략적으로 결정

## Consumer의 `auto.offset.reset`
* Consumer이 Topic에 처음 접속하여 Message를 가져올 때 가장 오래된 처음 offset부터(earliest) 가져올 것인지, 
  가장 최근인 마지막 offset 부터(latest) 가져올 것인지 설정한는 파라미터.
* default는 latest이다.
  * `auto.offset.reset=earliest` : 처음 offset 부터 읽음
  * `auto.offset.reset=latest` : 마지막 offset 부터 읽음

## Producer과 Consumer 간의 Serialized Message 전송
![카프카완벽가이드_5.png](/kafka/images%2F%EC%B9%B4%ED%94%84%EC%B9%B4%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C_5.png)
* Broker의 Partition에 저장된 데이터 형태는 Byte Array이다.
* 따라서 Producer에서 데이터는 Serialized 되어야한다.
* Consumer은 역직렬화해서 데이터를 객체 형태로 사용한다.
* Java에서 기본타입 Serializer을 제공해주고 있지만 Object를 사용할땐 Serialize를 구현해주어야한다. 

---
## Key 값을 가지는/가지지않는 메시지의 순서 보장 여부
* Topic이 여러 개의 파티션을 가질 때 메시지의 전송 순서가 보장되지 않은 채로 Consumer에서 읽혀질 수 있음
  * 카프카는 하나의 파티션 내에서만 메시지 순서를 보장함
* 다만 **key값을 가지는 메시지라면 특정 파티션으로 고정되어 전송할 수 있음**
  * 하나의 파티션에만 메시지가 들어갈 수 있다면 순서 보장을 할 수 있음

## 파티션 분배 전략
### Key가 없는 메시지인 경우
* **라운드로빈(RR)**
  * kafka 2.4버전 이전 기본 파티션 분배 전략
  *  메시지를 파티션에 균일하게 분배하려는 전략으로 **메시지 배치를 순차적으로 다른 파티션으로 전송**
  * 메시지가 배치 데이터를 빨리 채우지 못하면서 전송이 늦어지거나 배치를 다 채우지 못하고 전송하게 되어 성능 문제 발생
  ![카프카완벽가이드_6.png](/kafka/images%2F%EC%B9%B4%ED%94%84%EC%B9%B4%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C_6.png)
* **스티키 파티셔닝(Sticky Partitioning)**
  * kafka 2.4.버전부터 기본 파티션 분배 전략
  * 하나의 배치에 메시지를 빠르게 먼저 채워서 보내는 방식
  ![카프카완벽가이드_7.png](/kafka/images%2F%EC%B9%B4%ED%94%84%EC%B9%B4%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C_7.png)

---
## Consumer Group 과 Consumer
* 모든 Consumer들은 단 하나의 Consumer Group에 소속되어야한다.
* 파티션 레코드들은 Grooup안에선 단 하나의 Consumer에만 할당된다.

![카프카완벽가이드_8.png](/kafka/images%2F%EC%B9%B4%ED%94%84%EC%B9%B4%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C_8.png)
* 보통 partition의 개수와 Consumer의 개수를 동일하게 두고 사용함(병렬처리 하기 위함)
* Consumer Group 내에 Consumer 변화가 있을 때마다 파티션과 Consumer의 조합을 변경하는 Rebalancingg이 발생한다. 

![카프카완벽가이드_9.png](/kafka/images%2F%EC%B9%B4%ED%94%84%EC%B9%B4%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C_9.png)
* Consumer Group이 다른 컨슈머는 아예 별개로 본다.