# 1장. 오브젝트와 의존관계
> '스프링이 어떤 것이고, 무엇을 제공하는지'보다는 
> 스프링이 관심을 갖는 대상인 **오브젝트의 설계와 구현, 동작원리**에 더 집중하기

## 1. 개선이 필요한 DAO
```java
public class UserDao {
    // JDBC API가 만들어내는 Exception을 메서드 밖으로 던진다
    public User get(String id) throws ClassNotFoundException, SQLException {
        // DB 연결을 위한 Connection 가져오기
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection(
                "jdbc:mysql://localhost/springbook", "spring", "book");
        
        // SQL을 담은 Statement를 만든다
        PreparedStatement ps = c.prepareStatement("select * from users where id = ?");
        ps.setString(1, id);

        // 만들어진 Statement를 실행한다
        ResultSet rs = ps.executeQuery();
        rs.next();
        // SQL 쿼리의 실행 결과를 ResultSet으로 받아서 정보를 저장할 오브젝트에 옮겨준다.
        User user = new User();
        user.setId(rs.getString("id"));
        
        // 작업중에 생성된 Connection, Statement, ResultSet 같은 리소스를 닫아준다.
        rs.close();
        ps.close();
        c.close();
        
        return user;
    }
}
```
### UserDao 클래스의 관심사
1) DB 연결을 위한 커넥션을 가져오는 것
2) DB로 보낼 SQL 문장에 파라미터를 바인딩시키고, 실행하는 것
3) 작업이 끝나면 리소스 오브젝트를 닫는 것

---
## 2. 이미 충실하게 기능을 수행 중인 코드를 개선해야하는 이유는 무엇인가?
> * 이 DAO는 기대한 기능을 충실히 수행한다. 그럼에도 **이 코드를 수정하고 개선해야하는 이유는 무엇인가?**
> 
>   * 잘 동작하는 코드를 굳이 수정하고 개선해야 하는 이유는 무엇인가?
>   * DAO 코드를 개선했을 때의 장점은 무엇인가?
>   * 이런 장점이 당장에, 미래에 주는 유익은 무엇인가?
>   * 객체지향 설계의 원칙과는 무슨 상관이 있을까?
>   * DAO를 개선하는 경우와 그대로 사용하는 경우, 스프링을 사용하는 개발에서 무슨 차이가 있을까?
>
> > 책 읽기 전 나의 포괄적인 답변:
> > 새로운 기능을 추가하거나 기존 기능에 수정이 필요할 때 복잡한 코드 탓에 개발 공수가 많이 들고, 유지보수에 좋지 않다. 

### 2.1. 오브젝트에 대한 설계와 이를 구현한 코드는 계속 변한다
* 사용자 비즈니스 프로세스와 요구사항은 끊임없이 변함
* 애플리케이션이 기반을 두고 있는 기술도 시간이 지남에 따라 변함
* 운영되는 환경도 변함

### 2.2. 객체지향 프로그래밍은 변화에 변화의 폭을 최소한을 줄이는 것이 목적이다
* 객체지향 설계와 프로그래밍은 절차적 프로그래밍 패러다임에 비해 초기에 더 번거로운 작업을 요구하지만, 
  변화에 효과적으로 대처할 수 있다는 기술적인 특징을 가지고 있다.
* 객체지향 프로그래밍은 실세계를 최대한 가깝게 모델링 할 수 있어서 의미 있는 것이 아니다.
* 객체지향 기술이 만들어내는 가상의 추상세계를 효과적으로 구성하고, **자유롭고 편리하게 변경, 확장 시킬수 있다는 것에 의미**가 있다.

### 2.3. 변화의 폭을 최소한으로 줄이는 것: 관심사의 분리와 확장
> 모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다.
* 분리: 한 곳에 모여있는 다양한 관심사 → 한 곳에 하나의 관심사만 있도록 집중시키는 것
* 확장: // TODO

---

## 3. 첫번째 관심사 리팩토링 : DB 연결을 위한 커넥션을 가져오는 것
### 개선해야하는 이유
* Connection 가져오는 코드가 다른 관심사와 섞여있고
* DB 커넥션에 대한 정보가 모든 메서드에 하나씩 존재해서 DB 연결에 대한 정보가 변경되면 모든 메서드를 수정해야함

### 3.1. 첫 번쨰 개선: 메서드 추출로 변경점 한 곳으로 집중
```java
public class UserDao{
    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection c = getConnection();
        // 생략
    }
    public Connection getConnection() throws ClassNotFoundException {
        Class.forName("com.mysql.jdbc.Driver");
        return DriverManager.getConnection(
                "jdbc:mysql://localhost/springbook", "spring", "book");
    }
}
```

---
### 3.2. 두 번째 개선: 사용하는 Connection 객체가 달라질 경우 대비해 팩토리 메서드 패턴 사용
```java
public abstract class UserDao{
    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection c = getConnection();
        // 생략
    }
    // 서브 클래스에서 구현
    public abstract Connection getConnection() throws ClassNotFoundException;
```
#### 이 방법의 단점: 상속을 사용함
* 이미 상속관계가 존재하는 클래스면 사용 불가능
* 상하위 클래스의 관계가 너무 밀접해짐

---
### 3.3. 세 번째 개선: 클래스를 분리해서 상속이 아닌 Composition 을 사용
```java
public interface ConnectionMaker {
    Connection makeConnection();
}

public class UserDao {
    private ConnectionMaker connectionMaker;

    public UserDao(ConnectionMaker connectionMaker) {
        this.connectionMaker = connectionMaker;
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection c = connectionMaker.makeConnection();
        // 생략
    }
}
```
#### 1) Client에게 오브젝트-오브젝트 간의 관계를 설정할 책임을 이관
* 전략패턴을 사용함으로써 런타임에 사용할 구현체를 결정할 책임을 UserDao 오브젝트를 사용할 Client 오브젝트에게 이관하였다.
* 인터페이스를 사용해 `UserDao`와 `ConnectionMaker`이 "느슨한 관계"를 맺어 구현체 변경에 영향이 없도록 한다.  

#### 2) 전략패턴을 사용함으로써 상속에 비해 더 유연함을 가짐
* 상속: `UserDao`를 상속했기에 해당 기능은 오직 `UserDao`에서의 사용만을 의도함
* 전략패턴:`ConnectionMaker`이 가진 책임을 필요로 하는 모든 곳에서 사용 가능

#### 3) 책임이 완벽히 분리 : 개방-폐쇄법칙, 응집도⇡/결합도⇣
`UserDao`는 "2) DB로 보낼 SQL 문장에 파라미터를 바인딩시키고, 실행하는 것", "3) 작업이 끝나면 리소스 오브젝트를 닫는 것"
의 책임만을 갖고 "1) DB 연결을 위한 커넥션을 가져오는 것"에 관한 책임을 `ConnectionMaker`로 완전히 분리시킴.

#### 이 방법의 단점:
* 결국 Client인 `UserDaoTest`에서 오브젝트간의 관계(=사용할 구현체를 결정)할 책임을 떠넘긴 것
* 계속 앞단으로 미루는 꼴이며, 누군가는 이 책임을 가지고 있어야한다.

---
### 4) 네 번째 개선: 오브젝트간의 관계를 설정할 책임을 Client가 아닌 또 '설계'객체에게 위임(IoC)
```java
public class DaoFactory {
	public UserDao userDao() {
		ConnectionMaker connectionMaker = new DConnectionMaker();
		UserDao userDao = new UserDao(connectionMaker);
		return userDao;
	}
}

public class UserDaoTest {
    public static void main(String[] args) {
        UserDao userDao = new DaoFactory().userDao();
        // 생략
    }
}
```
* `DaoFactory`는 애플리케이션을 구성하는 컴포넌트의 구조와 관계를 정의하는 "설계도" 역할
* 앞서 확인한 `UserDao` 등의 클래스는 실질적인 로직을 담당하는 컴포넌트
* 컴포넌트들의 제어권을 `DaoFactory`에 위임한 것 → 제어의 역전(IoC)

#### 주목할 점
* 오브젝트간의 관계(=사용할 구현체를 결정)할 책임을 최종적으로 
  `DaoFactory`라는 "설계 오브젝트"에게 위임했다.

---
## 4. 스프링의 IoC
### 4.1. 용어 정리
> bean factory  = application context = container
* **빈(Bean)**
  * 스프링이 IoC 방식으로 관리하는 오브젝트
  * 스프링을 사용하는 애플리케이션에서 만들어지는 모든 오브젝트 중
    스프링이 직접 그 생성과 제어를 담당하는 오브젝트만을 빈이라고 한다

* **빈 팩토리(Bean Factory)**
  * 빈을 등록/생성/조회/반환 등을 관리하는 기능을 담당하는 스프링의 IoC를 담당하는 핵심 컨테이너를 가리킨다.
  * 보통 빈 팩토리를 바로 사용하는 것이 아닌 이를 확장한 애플리케이션 컨텍스트를 이용한다.

* **애플리케이션 컨텍스트(application context)**
  * 빈 팩토리를 확장(상속)한 IoC 컨테이너.
  * 빈 팩토리의 기능에서 스프링이 제공하는 각종 부가서비스를 추가로 제공한다.
  * 빈을 관리하기 위한 청사진(=메타정보)을 **실행**하는 오브젝트. 청사진은 외부에서 제공받는다.
  * application context는 인터페이스로 존재하고 이를 상속한 구현체들이 여럿 존재한다.

* **설정정보/설정 메타정보(configuration metadata)**
  * 애플리케이션 컨텍스트 혹은 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보
  * 빈 오브젝트를 생성하고 구성할 때 사용된다.

* **컨테이너/IoC 컨테이너(container)**
  * application context와 bean factory를 부르는 또다른 용어
  * 컨테이너라는 말 자체가 IoC 개념을 담고 있다.
    * "container"은 **담고 관리하는 그릇/환경**을 가리킬 때 사용하는 용어

---
### 4.2. application context의 동작방식
`AnnotationConfigApplicationContext`/`singleton` 스코프의 경우
1. `@Configuration`이 붙은 설정메타정보를 등록
2. 설정 메타정보를 해석해서 빈 정의(BeanDefinition)들을 등록
3. Client가 application context의 getBean()을 호출하면 빈 목록에서 요청한 이름 검색
4. 이미 생성돼 있으면 캐시에서 반환하고, 없으면 정의를 바탕으로 생성해서 반환
   * singleton 스코프라면 context를 만들고 초기화하는 단계에 미리 싱글톤 빈들 생성
   * `@Lazy`가 붙거나, `prototype` 스코프 빈이면 `getBean()`이 실행되는 단계에 생성해서 반환

---
### 4.3. Spring이 자바레벨에서 관계를 관리하는 것(DaoFactory)보다 나은 이유
#### 1) 애플리케이션 컨텍스트는 클라이언트가 구체적인 팩토리 클래스를 알 필요가 없다.
* as-is: 
  * 클라이언트가 어떤 팩토리 클래스를 사용할 건지 알아야함
  * 팩토리 클래스에 매번 오브젝트를 직접 추가해야함
* to-be:
  * 클라이언트는 팩토리 클래스를 알 필요가 없음-메타정보만 설정해서 Application Context에 설정해주면 애플리케이션 모든 내부에서 적용되기 때문
  * 후에 나오지만 `Annotation`을 이용해서 직접 추가하지 않을 수 있음 

#### 2) 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공한다.
* as-is:
    * 실행하는 시점에 오브젝트를 생성 및 전략이 동일함
* to-be:
    * 빈 생성 방식/시점/전략을 다양하게 가져갈 수 있고
    * 자동생성, 오브젝트에 대한 후처리, 정보의 조합, 설정방식 다변화 등 여러 기능 제공

#### 3) 애플리케이션 컨텍스트는 Bean을 검색하는 다양하나 방법을 제공한다.
* as-is:
    * 미리 지정된 태그만으로 빈을 찾을 수 있다
* to-be:
    * 인터페이스/구현체 이름/타입 등 다양한 방식 빈을 찾을 수 있다.

---
## 5. Spring을 사용한 DAO 클래스 리팩토링
### 5.1. `DaoFactory`를 Application Context의 설정메타정보로 변경
```java
@Configuration // application context 또는 Bean Factory가 사용하는 설정정보라는 표시
public class DaoFactory {
    @Bean // Bean 생성을 담당하는 IoC용 메서드라는 표시 
    public UserDao userDao() {
        return new UserDao(connectionMaker());
    }

    @Bean
    public ConnectionMaker connectionMaker() {
        return new DConnectionMaker();
    }
}
```
* `DaoFactory`는 "애플리케이션을 구성하는 컴포넌트의 구조와 관계를 정의"에 대한 정보이기에
* 생성된 빈의 이름은 `@Bean`이 붙은 **메서드의 이름**과 동일하게 생성된다.
  * 동일한 타입의 오브젝트가 Bean으로 생성될 수 있기 때문

---
### 5.2. 메타정보를 사용하여 IoC를 구성해줄 Application Context 생성
```java
public class UserDaoTest {
    public static void main(String[] args) throws Exception {
        ApplicationContext context = 
                new AnnotationConfigApplicationContext(DaoFactory.class);
        UserDao dao = context.getBean("userDao", UserDao.class);
        // 생략
    }
}
```
* ApplicationContext를 구현한 클래스는 여러가지 존재한다
* `@Configuration`이 붙은 자바 코드를 설정정보를 사용한다면 `AnnotationConfigApplicationContext`를 사용한다.

---
## 6. Spring이 Bean을 관리하는 방법
### 6.1. Spring은 싱글톤 레지스트리이다.
* Spring이 빈으로 관리하는 오브젝트는 기본적으로 `singleton 스코프`를 사용한다.
* 싱글톤 패턴을 사용하지 않고 IoC컨테이너가 싱글톤으로 관리하는 것이다  
* Bean을 평범한 자바 클래스로 만들 수 있기에 
  싱글톤패턴의 여러 단점을 상쇄하면서, 장점은 취할 수 있다.

---
### 6.2. Spring이 싱글톤 레지스트리여야하는 이유.
* 스프링이 주로 적용되는 대상은 자바 엔터프라이즈 기술을 사용하는 서버 환경이다
  > 엔터프라이즈(Enterprise) :대규모 데이터 처리, 보안, 안정성이 중요한 중대형 규모의 기업용 제품이나 서비스
* 따라서 서버 하나당 수많은 요청을 처리할 수 있는 높은 성능이 요구된다.
* 매 요청이 올 떄마다 오브젝트를 새로 만들어서 사용하면 부하가 걸리기 때문에 
* 동일한 이유로 Servlet 또한 싱글톤으로 동작하는 오브젝트로, 멀티 스레드에서 하나의 오브젝트를 공유해 동시에 사용한다.

---
### 6.3. Bean이 싱글톤으로 관리되기에 주의해야할 점
#### 싱글톤의 유의점과 동일하게 "인스턴스 필드" 설정에 유의한다 
* 변경될 수 있는 정보는 인스턴스 필드로 설정해서는 안된다.
* 하지만 "읽기전용"은 인스턴스 필드로 설정해도 괜찮다.
  ```java
  public class UserDao{
    private ConnectionMaker connectionMaker; // 초기 설정하면 변경되지 않는 읽기 전용 인스턴스
    // 생략
  }
  ```
  * Bean은 늘 동일한 오브젝트이므로 인스턴스 필드로 사용해도 문제가 없다. 

---
## 7. Spring이 IoC를 제공하는 구체적인 동작원리: **DI** (+의존관계검색)
> DI가 가능한 이유는 오브젝트간의 관계를 맺는 제 3자가 존재하기 떄문이다.
> 즉, 스프링은 IoC를 기반으로 DI를 제공하여 "느슨한 관계"를 

### 7.1. DI관련 용어 정리
* **의존관계**
  * `A --> B`: B에 변경사항이 있다면 A가 영향받는 관계
  * 의존관계에는 **방향**이 있다

* **런타임 의존관계**
  * 설계시점(=코드)의 의존관계까 아닌, 런타임에 컨테이너가 관계를 맺어주는 관계

* **의존 오브젝트**
  * 런타임에 의존관계를 맺는 구체 오브젝트. 
  * 의존관계의 관계성으로 따지면 `B`에 해당

* **DI(의존관계 주입)**
  * 의존 오브젝트와 클라이언트 오브젝트를 런타임 시에 연결해주는 작업

---
### 7.2. DI 기능 덕분에 오브젝트간 "느슨한관계"를 만들 수 있다
* 코드 설계 시점에 Client 오브젝트는 구현체를 알지 못해도, Spring이 DI를 통해 구현체를 주입해준다.
* 계속 앞단으로 미룬 "관계를 맺을 구현체를 결정하는 책임"을 Spring이 가져고, DI를 통해 실현하는 것이다.

---
### 7.3. Spring이 제공하는 DI 외의, IoC 제공 방법: 의존관계 검색
```java
    UserDao dao = context.getBean("userDao", UserDao.class);
```
* Client에서 런타임에 사용할 진짜 오브젝트를 알고 있어야하므로 DI가 제공하는 "느슨한 관계"를 맺을 수 없다
* 단, CLient가 Bean이 아니여도 된다.
  * DI는 Client와 의존오브젝트 모두 Bean이여야한다.

---
### 7.4. DI의 활용 예시
#### 1) 구현체의 교환
* 문제: 개발환경과 운영환경의 DB Connection 정보를 다르게 주어야 함.
* 해결: 환경에 따라 생성되는 Bean의 메타정보만 다르게 해줌 → 구현 코드는 변경하지 않아도 됨.

#### 2) 부가 기능의 추가
* 문제: 기존에 사용하던 method의 실행 횟수를 확인해야하는 상황
* 해결: 데코레이트 패턴을 사용한 객체를 생성한 뒤, 이를 Bean으로 생성 
  * → 기존 Client 코드와 의존오브젝트 코드는 변경없이, DI를 통해 중간단계를 생성. 

---
## 개인적인 메모
### 리팩토링 방법
1. 현재 클래스/메서드가 가진 "관심사"가 무엇인지 확인하기
2. 각 관심사가 갖고 있는 문제를 확인하고 "분리"하기
   1) 다른 관심사와 섞여서 하나의 메서드에 존재하고, 여러 메서드에 DB 커넥션 정보가 중복되어있음 → 개별 메서드로 분리
   2) 메서드내에서 생성해야하는 오브젝트가 상황에 따라 변경될 수 있음 → 템플릿/팩토리 메서드패턴 등 사용한 서브클래스로 분리
   3) 상속의 단점을 보완 → 전략패턴으로 분리
3. 리팩토링된 코드 테스트하기 : 기존의 테스트 코드를 돌려보기