# 3. 템플릿
## 1. 해결 과제
* 목적: 변하는 것과 변하지 않는 것을 분리하려고 함
* 문제: 변하지 않는 것 내부에 변하는 것이 감싸고 있는 상태

```java
public void deleteAll() {
    Connection c = null;
    PreparedStatement ps = null;
    try {
        c = dataSource.getConnection();

        //////////////// 변하는 부분 //////////////
        ps = c.prepareStatement("delete from users");
        //////////////////////////////////////////
        
    } catch (Exception e) {
        // 생략
    } finally {
        // 생략
    }
}
```
## 2. 변하는 것과 변하지 않는 것의 분리
### 첫번째: 메서드 추출
```java
public void deleteAll() {
    Connection c = null;
    PreparedStatement ps = null;
    try {
        c = dataSource.getConnection();

        ps = makeStatement(c);
    } catch (Exception e) {
        // 생략
    } finally {
        // 생략
    }
}

public PrepareStatment makeStatment(Connection c) {
    PrepareStatment ps;
    ps = c.prepareStatement("delete from users");
    return ps;
}
```
* 메서드 추출해도 변하는 것이 변하는 것을 호출해야하기 때문에 크게 의미 없음

### 두번째: 템플릿 메서드 패턴
```java
public abstract class Dao {
    public void deleteAll() {
        Connection c = null;
        PreparedStatement ps = null;
        try {
            c = dataSource.getConnection();

            ps = makeStatement(c);
        } catch (Exception e) {
            // 생략
        } finally {
            // 생략
        }
    }

    public abstract PrepareStatment makeStatment(Connection c);

}
```
* 개방폐쇄원칙(OCP)을 지킬 수 있지만 
* 문제:
  * DAO 로직마다 상속을 통해 새로운 클래스를 만들어야함
  * 확장구조가 고정되어있음(무조건 extends 상속)

### 세번째: 전략패턴
```java
public interface StatmentStrategy{
    PreparedStatment makePrepareStatment(Connection c);
}

public class DeleteALlStatment implements StatmentStrategy{
    public PrepareStatment makePrepareStatment(Connection c) {
        PrepareStatment ps;
        ps = c.prepareStatement("delete from users");
        return ps;
    }
}
```

```java
//public void deleteAll(StatmentStrategy strategy) {
public void jdbcContextWithStatementStrategy(StatmentStrategy strategy) { // delete에 국한되지 않아서 변경
    Connection c = null;
    PreparedStatement ps = null;
    try {
        c = dataSource.getConnection();
        ps = strategy.makePrepareStatment(c);
    } catch (Exception e) {
        // 생략
    } finally {
        // 생략
    }
}

public void deleteAll() {
    DeleteAllStatement deleteAllStatement = new DeleteAllStatement();
    jdbcContextWithStatementStrategy(deleteAllStatement);
}

public void add(final User user) {
    AddStatement addStatement = new AddStatement(user);
    jdbcContextWithStatementStrategy(addStatement);
}
```
* 개방폐쇄원칙(OCP)을 지킬 수 있고 확장구조가 비교적 자유로움
* 문제:
    * DAO 로직마다 상속을 통해 새로운 클래스를 만들어야함
    * 입력정보를 전략 클래스쪽에서 저장하고 있어야한다.

### 네번쨰: 전략패턴 + 익명클래스 (=템플릿/콜백패턴)
```java
public interface StatmentStrategy{
    PreparedStatment makePrepareStatment(Connection c);
}

public void jdbcContextWithStatementStrategy(StatmentStrategy strategy) { // delete에 국한되지 않아서 변경
    Connection c = null;
    PreparedStatement ps = null;
    try {
        c = dataSource.getConnection();
        ps = strategy.makePrepareStatment(c);
    } catch (Exception e) {
        // 생략
    } finally {
        // 생략
    }
}

public void deleteAll() {
    jdbcContextWithStatementStrategy(new StatementStrategy() {
        public PrepareStatment makePrepareStatment(Connection c) {
            PrepareStatment ps;
            ps = c.prepareStatement("delete from users");
            return ps;
        }
    });
}

public void add(final User user) {
    jdbcContextWithStatementStrategy(new StatementStrategy() {
        public PrepareStatment makePrepareStatment(Connection c) {
            PrepareStatment ps;
            ps = c.prepareStatement("insert into users values(?,?)");
            ps.setString(1, user.getId());
            ps.setString(2, user.getName());
            return ps;
        }
    });
}
```
* 생성해야하는 클래스 개수가 대폭 감소
* 입력정보를 전략 클래스 내에서 저장할 필요가 없음

### 다섯번째: 템플릿/콜백패턴에서 변경되는 점을 메서드 추출
```java
public void executeQuery(String query, String... vars){
    jdbcContextWithStatementStrategy(new StatementStrategy() {
        public PrepareStatment makePrepareStatment(Connection c) {
            PrepareStatment ps;
            ps = c.prepareStatement(query);
            for (int i = 1; i <= vars.length; i++) {
                ps.setString(i, vars[i]);
            }
            return ps;
        }
    });
}
    
public void add(final User user) {
    executeQuery("insert into users values(?,?)", user.getId(), user.getName());
}
```

