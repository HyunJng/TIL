# 1장. 오브젝트와 의존관계
> '스프링이 어떤 것이고, 무엇을 제공하는지'보다는 
> 스프링이 관심을 갖는 대상인 **오브젝트의 설계와 구현, 동작원리**에 더 집중하기

## 1. 개선이 필요한 DAO
```java
public class UserDao {
    // JDBC API가 만들어내는 Exception을 메서드 밖으로 던진다
    public User get(String id) throws ClassNotFoundException, SQLException {
        // DB 연결을 위한 Connection 가져오기
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection(
                "jdbc:mysql://localhost/springbook", "spring", "book");
        
        // SQL을 담은 Statement를 만든다
        PreparedStatement ps = c.prepareStatement("select * from users where id = ?");
        ps.setString(1, id);

        // 만들어진 Statement를 실행한다
        ResultSet rs = ps.executeQuery();
        rs.next();
        // SQL 쿼리의 실행 결과를 ResultSet으로 받아서 정보를 저장할 오브젝트에 옮겨준다.
        User user = new User();
        user.setId(rs.getString("id"));
        
        // 작업중에 생성된 Connection, Statement, ResultSet 같은 리소스를 닫아준다.
        rs.close();
        ps.close();
        c.close();
        
        return user;
    }
}
```
### UserDao 클래스의 관심사
1) DB 연결을 위한 커넥션을 가져오는 것
2) DB로 보낼 SQL 문장에 파라미터를 바인딩시키고, 실행하는 것
3) 작업이 끝나면 리소스 오브젝트를 닫는 것

---
## 2. 이미 충실하게 기능을 수행 중인 코드를 개선해야하는 이유는 무엇인가?
> * 이 DAO는 기대한 기능을 충실히 수행한다. 그럼에도 **이 코드를 수정하고 개선해야하는 이유는 무엇인가?**
> 
>   * 잘 동작하는 코드를 굳이 수정하고 개선해야 하는 이유는 무엇인가?
>   * DAO 코드를 개선했을 때의 장점은 무엇인가?
>   * 이런 장점이 당장에, 미래에 주는 유익은 무엇인가?
>   * 객체지향 설계의 원칙과는 무슨 상관이 있을까?
>   * DAO를 개선하는 경우와 그대로 사용하는 경우, 스프링을 사용하는 개발에서 무슨 차이가 있을까?
>
> > 책 읽기 전 나의 포괄적인 답변:
> > 새로운 기능을 추가하거나 기존 기능에 수정이 필요할 때 복잡한 코드 탓에 개발 공수가 많이 들고, 유지보수에 좋지 않다. 

### 오브젝트에 대한 설계와 이를 구현한 코드는 계속 변한다
* 사용자 비즈니스 프로세스와 요구사항은 끊임없이 변함
* 애플리케이션이 기반을 두고 있는 기술도 시간이 지남에 따라 변함
* 운영되는 환경도 변함

### 객체지향 프로그래밍은 변화에 변화의 폭을 최소한을 줄이는 것이 목적이다
* 객체지향 설계와 프로그래밍은 절차적 프로그래밍 패러다임에 비해 초기에 더 번거로운 작업을 요구하지만, 
  변화에 효과적으로 대처할 수 있다는 기술적인 특징을 가지고 있다.
* 객체지향 프로그래밍은 실세계를 최대한 가깝게 모델링 할 수 있어서 의미 있는 것이 아니다.
* 객체지향 기술이 만들어내는 가상의 추상세계를 효과적으로 구성하고, **자유롭고 편리하게 변경, 확장 시킬수 있다는 것에 의미**가 있다.

### 변화의 폭을 최소한으로 줄이는 것: 관심사의 분리와 확장
> 모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다.
* 분리: 한 곳에 모여있는 다양한 관심사 → 한 곳에 하나의 관심사만 있도록 집중시키는 것
* 확장: // TODO

---

## 3. 첫번째 관심사 리팩토링 : DB 연결을 위한 커넥션을 가져오는 것
### 개선해야하는 이유
* Connection 가져오는 코드가 다른 관심사와 섞여있고
* DB 커넥션에 대한 정보가 모든 메서드에 하나씩 존재해서 DB 연결에 대한 정보가 변경되면 모든 메서드를 수정해야함

### 첫 번쨰 개선: 메서드 추출로 변경점 한 곳으로 집중
```java
public class UserDao{
    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection c = getConnection();
        // 생략
    }
    public Connection getConnection() throws ClassNotFoundException {
        Class.forName("com.mysql.jdbc.Driver");
        return DriverManager.getConnection(
                "jdbc:mysql://localhost/springbook", "spring", "book");
    }
}
```

---
### 두 번째 개선: 사용하는 Connection 객체가 달라질 경우 대비해 팩토리 메서드 패턴 사용
```java
public abstract class UserDao{
    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection c = getConnection();
        // 생략
    }
    // 서브 클래스에서 구현
    public abstract Connection getConnection() throws ClassNotFoundException;
```
#### 이 방법의 단점: 상속을 사용함
* 이미 상속관계가 존재하는 클래스면 사용 불가능
* 상하위 클래스의 관계가 너무 밀접해짐

---
### 세 번째 개선: 클래스를 분리해서 상속이 아닌 Composition 을 사용
```java
public interface ConnectionMaker {
    Connection makeConnection();
}

public class UserDao {
    private ConnectionMaker connectionMaker;

    public UserDao(ConnectionMaker connectionMaker) {
        this.connectionMaker = connectionMaker;
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Connection c = connectionMaker.makeConnection();
        // 생략
    }
}
```
### 1) Client에게 오브젝트-오브젝트 간의 관계를 설정할 책임을 이관
전략패턴을 사용함으로써 런타임에 사용할 구현체를 결정할 책임을 UserDao 오브젝트를 사용할 Client 오브젝트에게 이관하였다.

### 2) 전략패턴을 사용함으로써 상속에 비해 더 유연함을 가짐
* 상속: `UserDao`를 상속했기에 해당 기능은 오직 `UserDao`에서의 사용만을 의도함
* 전략패턴:`ConnectionMaker`이 가진 책임을 필요로 하는 모든 곳에서 사용 가능

### 3) 책임이 완벽히 분리 : 개방-폐쇄법칙, 응집도⇡/결합도⇣
`UserDao`는 "2) DB로 보낼 SQL 문장에 파라미터를 바인딩시키고, 실행하는 것", "3) 작업이 끝나면 리소스 오브젝트를 닫는 것"
의 책임만을 갖고 "1) DB 연결을 위한 커넥션을 가져오는 것"에 관한 책임을 `ConnectionMaker`로 완전히 분리시킴.

---
## 네 번째 개선: 오브젝트간의 관계를 설정할 책임을 Client가 아닌 또 '설계'객체에게 위임(IoC)
```java
public class DaoFactory {
	public UserDao userDao() {
		ConnectionMaker connectionMaker = new DConnectionMaker();
		UserDao userDao = new UserDao(connectionMaker);
		return userDao;
	}
}

public class UserDaoTest {
    public static void main(String[] args) {
        UserDao userDao = new DaoFactory().userDao();
        // 생략
    }
}
```
* `DaoFactory`는 애플리케이션을 구성하는 컴포넌트의 구조와 관계를 정의하는 "설계도" 역할
* 앞서 확인한 `UserDao` 등의 클래스는 실질적인 로직을 담당하는 컴포넌트
* 컴포넌트들의 제어권을 `DaoFactory`에 위임한 것 → 제어의 역전(IoC)

---
## 개인적인 메모
### 리팩토링 방법
1. 현재 클래스/메서드가 가진 "관심사"가 무엇인지 확인하기
2. 각 관심사가 갖고 있는 문제를 확인하고 "분리"하기
   1) 다른 관심사와 섞여서 하나의 메서드에 존재하고, 여러 메서드에 DB 커넥션 정보가 중복되어있음 → 개별 메서드로 분리
   2) 메서드내에서 생성해야하는 오브젝트가 상황에 따라 변경될 수 있음 → 템플릿/팩토리 메서드패턴 등 사용한 서브클래스로 분리
   3) 상속의 단점을 보완 → 전략패턴으로 분리
3. 리팩토링된 코드 테스트하기 : 기존의 테스트 코드를 돌려보기