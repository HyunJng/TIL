# item 62. 다른 타입이 적절하다면 문자열 사용을 피하라
> * 적절한 타입이 있다면 **절대 문자열로 우회하지 말 것**.
    → 타입을 정의하는 것이 비용처럼 보일 수 있지만, 장기적으로 유지보수성과 안정성을 크게 높인다.

## 1. 개요

* 문자열은 매우 유연해서 여러 용도로 남용되기 쉬우며, 그 결과 **타입 안정성, 성능, 유지보수성**이 크게 떨어진다.
* 문자열을 ‘만능 데이터 타입’처럼 사용하는 것은 위험하며, **적절한 타입(전용 클래스, enum, 컬렉션 등)** 이 있다면 반드시 그 타입을 사용해야 한다.

## 2. 문자열을 피해야 하는 대표적인 경우

### 2.1. 문자열을 값 타입처럼 사용하는 경우

* 어떤 값(예: 좌표, 사용자 정보, 기간 등)을 문자열에 억지로 담아 표현하는 경우.
* `"10:20"` 같은 형태는 파싱과 검증이 어렵고 실수 가능성이 높다.
* **해결**: 전용 클래스를 만들어 필드를 명확히 타입으로 분리해 관리한다.

### 2.2. 문자열을 열거 타입처럼 사용하는 경우

* `"MALE"`, `"FEMALE"` 같은 문자열 상수를 상태 표현에 사용하는 경우.
* 오타나 잘못된 값이 들어가도 컴파일 타임에 잡히지 않는다.
* **해결**: `enum`을 사용하여 타입 안전성을 확보한다.

### 2.3. 문자열을 혼합 타입(여러 값의 조합)처럼 사용하는 경우

* 한 문자열에 여러 의미를 담는 경우. 예: `"username:role:level"`
* 구조가 암묵적이어서 해석하는 코드가 취약하며, 변경에 매우 약하다.
* **해결**: 명확한 필드를 가진 클래스를 정의한다.

### 2.4. 문자열을 권한, 설정값, 기능 토글 등의 키(key)처럼 사용하는 경우

* `"READ_ONLY"`, `"ADMIN_PRIV"` 같은 문자열 키는 오타에 취약하고 중복 위험이 있다.
* **해결**: 전용 클래스, enum, 혹은 상수 집합을 분리하거나, 필요하다면 Key 타입을 명시적으로 정의한다.

## 3. 왜 문자열 남용이 위험한가

* **타입 안정성 부족**
  컴파일 시점에 잘못된 값이 잡히지 않는다.
* **검증 부족**
  문자열은 내부 구조를 보장하지 않기 때문에 런타임 오류로 이어지기 쉽다.
* **표현력 부족**
  의미가 불명확하여 코드 읽기가 어렵다.
* **성능 문제**
  문자열 조작에는 많은 비용이 들 수 있다.
* **변경 취약성**
  문자열 포맷이 바뀌면 이를 사용하는 모든 코드가 깨지기 쉽다.

## 4. 좋은 대안들

* 전용 클래스를 만들어 **의도를 명확히 드러내기**
* `enum`으로 상태를 표현해 **타입 안전성** 확보
* 여러 데이터를 담아야 한다면 **클래스 or 레코드(record)** 형태로 구조화
* 설정값, 권한 등의 키에는 **별도 타입** 또는 **정적 상수 집합** 활용

---
> 추가적으로 궁금해져서 공부
### 실무에서 String을 Key로 사용하는 것은 권장된다
* String은 불변이고
* hashCode()가 캐싱되어 빠르고 안저억이고
* equals() 구현도 완벽하기 때문이다

그래서 아래 예시처럼 ** 문자열이 "데이터 자체"일 때는 문자열 key가 최선"이다
```java
Map<String, User> userByEmail;
Map<String, Integer> productCountByName;
Map<String, String> headers;
```

### item 62가 비판하는 "문자열 Key 남용"케이스
문제가 되는 것은 **문자열 데이터가 아닌데 문자열 key를 쓰는 상황**이다
* 문자열이 “텍스트”가 아니라
* 타입, 역할, 도메인 개념을 표현하기 위해 쓰이는 경우
```java
Map<String, Object> context;
context.put("USER_ID", 1234);   // user id라는 개념을 문자열로 표현
context.put("ROLE", "ADMIN");   // role이라는 enum 개념을 문자열로 표현
context.put("TX", 1030);        // transaction id라는 타입을 문자열로 표현
```
"원래 타입이 되어야 하는 곳"을 대체하는 것은 문자열 남용이다.

### 책에나온 ThreadLocal 예시의 리팩토링의 이유
* 준아님이 발표때 얘기한대로 String이 Key가 되면 ThreadLocal 목적이 충족되지 않을 수 있어서 첫번쨰 리팩토링을 함.
* ThreadLocal은 객체 자체에 Hash가 부여된다는 특성이 있으니 객제 자체가 Key역할을 할 수 있기에 두번째 리팩토링을 함