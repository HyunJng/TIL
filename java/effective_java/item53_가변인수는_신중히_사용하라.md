# item 53. 가변인수는 신중히 사용하라
> * 가변인수는 API 유연성과 가독성을 높여주지만 **모든 호출마다 배열 생성이라는 비용이 있다**.
> * 최소 1개 이상 받아야 하는 상황에서는 `첫 번째 인수 + varargs` 패턴을 사용할 것.
> * 성능 문제가 있는 경우 **고정 인수 오버로드 + varargs** 조합으로 최적화 가능.
> * 제네릭과 함께 사용할 때는 추가적인 타입 안전성 이슈가 있으므로 주의해야 한다.

## 1. 가변인수 기본 개념

* 메서드 선언부에 `타입... 변수명` 형태로 작성하면 0개 이상의 인수를 받을 수 있다.
* 호출 측에서 인수 개수를 자유롭게 전달할 수 있어 API의 표현력이 높아진다.
* 내부적으로는 **배열을 하나 생성하여** 그 안에 전달된 인수를 넣는다.

예시:

```java
static int sum(int... numbers) {
    int total = 0;
    for (int n : numbers) {
        total += n;
    }
    return total;
}
```

## 2. 가변인수의 비용 문제

* 호출될 때마다 **배열이 무조건 생성**된다.
* 자주 호출되거나 성능이 중요한 메서드라면 이 오버헤드가 문제가 될 수 있다.
* 인수가 “0개일 수도 있음”이 주는 복잡성도 존재한다.
  * 내부에서 로직상 오류가 발생할 수 있어 명시적으로 인입값 개수 검사를 해주어야한다.

## 3. 최소 1개 이상의 인수가 반드시 필요할 때의 패턴

가변인수를 받을 때 인수가 최소 1개 필요하지만, `int... numbers` 형태만 사용하면
사용자는 0개를 넣는 호출도 할 수 있다.

이를 방지하는 가장 좋은 패턴:

```java
static int min(int first, int... rest) {
    int result = first;
    for (int n : rest) {
        if (n < result) {
            result = n;
        }
    }
    return result;
}
```

* 첫 인수는 필수로 강제한다.
* 나머지 인수는 0개 이상 허용한다.
* 가독성, 타입 안정성, 런타임 오류 방지에 모두 유리하다.

## 4. 가변인수와 오버로딩 조합 시 문제

* varargs 메서드는 **오버로딩과 결합되면 호출 규칙이 모호**해질 수 있다.
* 컴파일러가 어떤 메서드를 선택할지 판단하기 어렵거나 의도치 않은 메서드가 선택될 위험이 있다.
* Effective Java 전반에서 강조되는 “오버로딩은 신중하게 사용할 것”과 동일한 맥락.

## 5. 성능 문제를 해결하기 위한 패턴 (오버로딩 + varargs)

빈번하게 호출되는 API라면 배열 생성 비용이 문제될 수 있다.

해결 방법:

1. 고정 인수 버전 메서드를 먼저 제공한다.
2. 추가 인수가 있을 때만 varargs 버전을 제공한다.

예시:

```java
public void process(String a) { ... }
public void process(String a, String b) { ... }
public void process(String a, String b, String... rest) { ... }
```

* 1개 또는 2개 인수를 주로 사용하는 경우 불필요한 배열 생성을 피한다.
* 나머지는 varargs 버전으로 처리한다.