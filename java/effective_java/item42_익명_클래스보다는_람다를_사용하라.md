# item 42. 익명 클래스보다는 람다를 사용하라
> * 람다는 **익명 클래스보다 간결하고, 의도를 명확히 드러낸다.**
> * 함수형 인터페이스 하나로 표현할 수 있다면 **익명 클래스 대신 람다를 써라.**
> * **단, 추상 메서드가 여러 개인 인터페이스**나 **상태를 추가해야 하는 경우**는 여전히 익명 클래스를 사용한다.
< * **람다를 직렬화하지 말라.** (익명 클래스보다 위험하고 이식성이 떨어진다.)

## 1. 배경

* **자바 8 이전**에는 간단한 동작(함수)을 객체로 표현해야 할 때 **익명 클래스(anonymous class)** 를 사용했다.
* 하지만 익명 클래스는 코드가 장황하고, 의도(“이건 함수 하나야”)가 명확히 드러나지 않았다.
* **자바 8 이후**에는 **람다(lambda)** 가 도입되어 **간결하고 명확하게 함수형 코드를 표현**할 수 있다.

---

## 2. 예시 비교

### (1) 익명 클래스 사용 (기존 방식)

```java
Collections.sort(words, new Comparator<String>() {
    @Override
    public int compare(String s1, String s2) {
        return Integer.compare(s1.length(), s2.length());
    }
});
```

* 클래스 선언 없이 바로 객체 생성.
* 코드가 **장황하고 가독성이 떨어진다**.
* 함수 하나만 전달하고 싶지만 **클래스 문법 전체를 써야 한다.**

---

### (2) 람다 사용 (Java 8+)

```java
Collections.sort(words,
        (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```

* 코드가 훨씬 **간결**하고, **함수적 의도**가 드러난다.
* 타입 추론 덕분에 매개변수 타입도 생략 가능.

---

### (3) 메서드 참조 (더 간결한 형태)

```java
Collections.sort(words, comparingInt(String::length));
```

* `Comparator.comparingInt` 정적 메서드와 **메서드 참조**(`String::length`) 조합.
* 표현하고자 하는 의도가 가장 명확하게 드러난다.

---

## 3. 람다의 특징

### (1) **타입 추론 (Type Inference)**

* 컴파일러가 문맥을 통해 매개변수 타입을 알아낼 수 있다.
* 따라서 대부분의 경우 **타입을 생략**할 수 있다.

### (2) **함수형 인터페이스(Functional Interface)**

* **하나의 추상 메서드만 가지는 인터페이스**는 람다식으로 표현 가능하다.
* 예: `Comparator<T>`, `Runnable`, `Callable<V>`, `Supplier<T>` 등
* `@FunctionalInterface`로 명시해 두면 컴파일러가 이를 검증해준다.

### (3) **자신만의 람다를 사용하고 싶을 때**

* 함수형 인터페이스를 직접 정의할 수 있다.

```java
@FunctionalInterface
interface Operation {
    int apply(int x, int y);
}
```

```java
Operation plus = (x, y) -> x + y;
```

---

## 4. 익명 클래스와 람다의 차이

| 구분      | 익명 클래스                     | 람다               |
| ------- | -------------------------- | ---------------- |
| 타입      | 명시적 클래스                    | 함수형 인터페이스로 추론    |
| 문법      | 장황함                        | 간결함              |
| this 참조 | 익명 클래스 자신                  | **바깥 인스턴스**      |
| 변수 캡처   | final 또는 effectively final | 동일하지만 의도적으로 더 단순 |
| 직렬화     | 지원 가능 (하지만 권장 X)           | **직렬화 비권장**      |

> **주의:** 람다는 익명 클래스와 달리 `this`가 **람다 자신이 아닌 외부 클래스**를 가리킨다.

---

## 5. 언제 익명 클래스를 여전히 써야 하는가

1. **추상 메서드가 여러 개 있는 인터페이스**를 구현해야 할 때
   → 람다는 **하나의 추상 메서드만 있는 함수형 인터페이스**에서만 사용 가능.

2. **인스턴스 필드나 상태를 추가해야 할 때**
   → 람다는 단일 함수 표현용이지, 필드를 갖는 객체를 표현하는 용도가 아니다.
