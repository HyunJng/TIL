> 헤드퍼스트 디자인 패턴을 보고 정리한 글입니다.
## 목차
- [전략패턴](#----)
- [옵저버 패턴](#------)
- [데코레이션 패턴](#--------)
- [팩토리 패턴](#------)
- [싱글턴 패턴](#------)
- [커맨드 패턴](#------)
- [어댑터 패턴](#------)
- [템플릿 메서드 패턴](#----------)
- [반복자 패턴](#------)
- [컴포지트 패턴](#-------)
- [상태 패턴](#-----)
- [프록시 패턴](#------)

## 전략패턴
- 모든 클래스에서 상속하지 않는 메서드만 interface로 구현해두어야한다
    - `Duck.class`에 `fly()`라는 메서드를 생성하면 고무오리도 날 수 있게 됨
- 그렇다고 `Flyable`이라는 인터페이스로 만들면 코드를 재사용할 수 없다

> 오리의 행동을 메서드로 구현하는게 아니라 다른 "클래스"에 역할을 위암한다

```
public abstract class  Duck {
       FlyBehavior flyBehavior; // 클래스로 Composition 하기
       QuackBehavior quackBehavior;
 
       public Duck() {
       }
 
       public void setFlyBehavior(FlyBehavior fb) {
              flyBehavior = fb;
       }
 
       public void setQuackBehavior(QuackBehavior qb) {
              quackBehavior = qb;
       }
 
       abstract void display();
 
       public void performFly() {
              flyBehavior.fly(); // 클래스 실행
0
 
       public void performQuack() {
              quackBehavior.quack();
       }
 
       public void swim() {
              System.out.println("All ducks float, even decoys!");
       }
}
```
![전략패턴.jpeg](/design_pattern/images/strategy_pattern_1.jpeg)

## 옵저버 패턴

## 데코레이션 패턴
## 팩토리 패턴
## 싱글턴 패턴
## 커맨드 패턴
## 어댑터 패턴
## 템플릿 메서드 패턴
## 반복자 패턴
## 컴포지트 패턴
## 상태 패턴
## 프록시 패턴

