> 헤드퍼스트 디자인 패턴을 보고 정리한 글입니다.
## 목차
- [전략패턴](#전략패턴)
- [옵저버 패턴](#옵저버-패턴)
- [데코레이션 패턴](#데코레이션-패턴)
- [팩토리 패턴](#팩토리-패턴)
- [싱글턴 패턴](#싱글턴-패턴)
- [커맨드 패턴](#커맨드-패턴)
- [어댑터 패턴](#어댑터-패턴)
- [템플릿 메서드 패턴](#템플릿-메서드-패턴)
- [반복자 패턴](#반복자-패턴)
- [컴포지트 패턴](#컴포지트-패턴)
- [상태 패턴](#상태-패턴)
- [프록시 패턴](#프록시-패턴)

## 전략패턴
- 모든 클래스에서 상속하지 않는 메서드만 interface로 구현해두어야한다
    - `Duck.class`에 `fly()`라는 메서드를 생성하면 고무오리도 날 수 있게 됨
- 그렇다고 `Flyable`이라는 인터페이스로 만들면 코드를 재사용할 수 없다

> 오리의 행동을 메서드로 구현하는게 아니라 다른 "클래스"에 역할을 위암한다

```
public abstract class  Duck {
       FlyBehavior flyBehavior; // 클래스로 Composition 하기
       QuackBehavior quackBehavior;
 
       public Duck() {
       }
 
       public void setFlyBehavior(FlyBehavior fb) {
              flyBehavior = fb;
       }
 
       public void setQuackBehavior(QuackBehavior qb) {
              quackBehavior = qb;
       }
 
       abstract void display();
 
       public void performFly() {
              flyBehavior.fly(); // 클래스 실행
0
 
       public void performQuack() {
              quackBehavior.quack();
       }
 
       public void swim() {
              System.out.println("All ducks float, even decoys!");
       }
}
```
![전략패턴.jpeg](/design_pattern/images/strategy_pattern_1.jpeg)

---
## 옵저버 패턴
- 특정 객체의 상태에 따라 어떠한 작업을 실행시켜야할 때(trigger)
> subject를 observer이 구독하게 만들어 느슨한 결합을 시킨다

```java
public interface Subject{
	// Observer를 인자로 받아 옵저버를 등록하거나 제거함
	public void registerObserver(Observer o); 
    public void removeObserver(Observer o);
    // 주제의 상태가 변경되었을 때 모든 옵저버에게 변경 내용을 알림
    public void notifyObservers();
}

// 모든 옵저버 클래스에서 구현해야 함
// 따라서 모든 옵저버는 update() 메소드를 구현해야 함
public interface Observer{
	public void update(float temp, float humidity, float pressure);
}

// 디스플레이 항목을 화면에 표시해야 할 때 메소드를 호출함
public interface DisplayElement{
	public void display();
}
```
**subject 예시**
```java
public class WeatherData implements Subject {
	private List<Observer> observers; 
	private float temperature;
	private float humidity;
	private float pressure;
	
	public WeatherData() {
		observers = new ArrayList<Observer>(); // 생성자가 a의 객체 생성
	}
	
    // 여기서부터 notifyObservers() 까지는 Subject 인터페이스를 구현하는 부분
    // 옵저버가 등록을 요청하면 목록 맨 뒤에 추가
	public void registerObserver(Observer o) {
		observers.add(o);
	}
	
    // 옵저버가 탈퇴를 요청하면 목록에서 뺌
	public void removeObserver(Observer o) {
		observers.remove(o);
	}
	
    // 모든 옵저버에게 상태 변화를 알려주는 부분
    // 모두 Observer 인터페이스를 구현하는, update() 메소드가 있는 객체들이므로 손쉽게 상태 변화를 알려줄 수 있음
	public void notifyObservers() {
		for (Observer observer : observers) {
			observer.update(temperature, humidity, pressure);
		}
	}
	
    // 기상 스테이션으로부터 갱신된 측정값을 받으면 옵저버들에게 알림
	public void measurementsChanged() {
		notifyObservers();
	}
	
	public void setMeasurements(float temperature, float humidity, float pressure) {
		this.temperature = temperature;
		this.humidity = humidity;
		this.pressure = pressure;
		measurementsChanged(); // 실제 장비에서 기상 데이터를 가져오는 대신 메소드를 활용해 디스플레이 항목을 테스트
	}
    
	// 기타 WeatherData 메소드
	public float getTemperature() {
		return temperature;
	}
	
	public float getHumidity() {
		return humidity;
	}
	
	public float getPressure() {
		return pressure;
	}

}
```
![observer_pattern_1.png](/design_pattern/images/observer_pattern_1.png)
## 데코레이션 패턴
## 팩토리 패턴
## 싱글턴 패턴
## 커맨드 패턴
## 어댑터 패턴
## 템플릿 메서드 패턴
## 반복자 패턴
## 컴포지트 패턴
## 상태 패턴
## 프록시 패턴

