> 헤드퍼스트 디자인 패턴을 보고 정리한 글입니다.
## 목차
- [전략패턴](#전략패턴)
- [옵저버 패턴](#옵저버-패턴)
- [데코레이션 패턴](#데코레이션-패턴)
- [팩토리 패턴](#팩토리-패턴)
- [싱글턴 패턴](#싱글턴-패턴)
- [커맨드 패턴](#커맨드-패턴)
- [어댑터 패턴](#어댑터-패턴)
- [템플릿 메서드 패턴](#템플릿-메서드-패턴)
- [반복자 패턴](#반복자-패턴)
- [컴포지트 패턴](#컴포지트-패턴)
- [상태 패턴](#상태-패턴)
- [프록시 패턴](#프록시-패턴)

## 패턴 원칙
> - 바뀌는 부분은 캡슐화 한다. 
> - 상속보다는 구성을 활용한다. 
> - 구현보다는 인터페이스에 맞춰서 프로그래밍한다. 
> - 상호작용하는 객체 사이에서는 가능하면 느슨한 결합을 사용해야 한다. 
> - 클래스는 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야 한다. (OCP)
> - 추상화된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만든다.

## 전략패턴
- 모든 클래스에서 상속하지 않는 메서드만 interface로 구현해두어야한다
    - `Duck.class`에 `fly()`라는 메서드를 생성하면 고무오리도 날 수 있게 됨
- 그렇다고 `Flyable`이라는 인터페이스로 만들면 코드를 재사용할 수 없다

> 오리의 행동을 메서드로 구현하는게 아니라 다른 "클래스"에 역할을 위암한다

```
public abstract class  Duck {
       FlyBehavior flyBehavior; // 클래스로 Composition 하기
       QuackBehavior quackBehavior;
 
       public Duck() {
       }
 
       public void setFlyBehavior(FlyBehavior fb) {
              flyBehavior = fb;
       }
 
       public void setQuackBehavior(QuackBehavior qb) {
              quackBehavior = qb;
       }
 
       abstract void display();
 
       public void performFly() {
              flyBehavior.fly(); // 클래스 실행
0
 
       public void performQuack() {
              quackBehavior.quack();
       }
 
       public void swim() {
              System.out.println("All ducks float, even decoys!");
       }
}
```
![전략패턴.jpeg](/design_pattern/images/strategy_pattern_1.jpeg)

---
## 옵저버 패턴
- 특정 객체의 상태에 따라 어떠한 작업을 실행시켜야할 때(trigger)
> subject를 observer이 구독하게 만들어 느슨한 결합을 시킨다

```java
public interface Subject{
	// Observer를 인자로 받아 옵저버를 등록하거나 제거함
	public void registerObserver(Observer o); 
    public void removeObserver(Observer o);
    // 주제의 상태가 변경되었을 때 모든 옵저버에게 변경 내용을 알림
    public void notifyObservers();
}

// 모든 옵저버 클래스에서 구현해야 함
// 따라서 모든 옵저버는 update() 메소드를 구현해야 함
public interface Observer{
	public void update(float temp, float humidity, float pressure);
}

// 디스플레이 항목을 화면에 표시해야 할 때 메소드를 호출함
public interface DisplayElement{
	public void display();
}
```
**subject 예시**
```java
public class WeatherData implements Subject {
	private List<Observer> observers; 
	private float temperature;
	private float humidity;
	private float pressure;
	
	public WeatherData() {
		observers = new ArrayList<Observer>(); // 생성자가 a의 객체 생성
	}
	
    // 여기서부터 notifyObservers() 까지는 Subject 인터페이스를 구현하는 부분
    // 옵저버가 등록을 요청하면 목록 맨 뒤에 추가
	public void registerObserver(Observer o) {
		observers.add(o);
	}
	
    // 옵저버가 탈퇴를 요청하면 목록에서 뺌
	public void removeObserver(Observer o) {
		observers.remove(o);
	}
	
    // 모든 옵저버에게 상태 변화를 알려주는 부분
    // 모두 Observer 인터페이스를 구현하는, update() 메소드가 있는 객체들이므로 손쉽게 상태 변화를 알려줄 수 있음
	public void notifyObservers() {
		for (Observer observer : observers) {
			observer.update(temperature, humidity, pressure);
		}
	}
	
    // 기상 스테이션으로부터 갱신된 측정값을 받으면 옵저버들에게 알림
	public void measurementsChanged() {
		notifyObservers();
	}
	
	public void setMeasurements(float temperature, float humidity, float pressure) {
		this.temperature = temperature;
		this.humidity = humidity;
		this.pressure = pressure;
		measurementsChanged(); // 실제 장비에서 기상 데이터를 가져오는 대신 메소드를 활용해 디스플레이 항목을 테스트
	}
    
	// 기타 WeatherData 메소드
	public float getTemperature() {
		return temperature;
	}
	
	public float getHumidity() {
		return humidity;
	}
	
	public float getPressure() {
		return pressure;
	}

}
```
![observer_pattern_1.png](/design_pattern/images/observer_pattern_1.png)
---
## 데코레이션 패턴
- 객체의 타입과 호출 가능한 메소드를 그대로 유지하면서 객체에 새로운 책임을 추가할 때 사용한다.
- 탈부착 가능한 책임을 정의할 때 사용한다.
- 상속을 통해 서브클래스를 계속 만드는 방법이 비효율적일 때 사용한다.
  = 특히 조합되는 경우의 수가 많으면 서브클래스 수가 폭발적으로 늘어날 수 있다.
```java
// 음료
abstract class Beverage {
  String description = "제목 없음";

  public String getDescription() { return description; }
  public abstract double cost();

  @Override
  public String toString() {
    return getDescription() + ": $" + cost();
  }
}

// 첨가물
abstract class CondimentDecorator extends Beverage { // 상속을 통해 같은 인터페이스 갖게 하는 것이 주요 포인트
  public abstract String getDescription();
} 
```
```java
class Espresso extends Beverage {
    public Espresso() { description = "에스프레소"; }

    @Override
    public double cost() { return 1.99; }
}

class Mocha extends CondimentDecorator {
  Beverage beverage;

  public Mocha(Beverage beverage) {
    description = "모카";
    this.beverage = beverage;
  }

  @Override
  public double cost() {
    // 중요한 부분
    return 0.20 + beverage.cost();
  }

  @Override
  public String getDescription() {
    // 중요한 부분
    return beverage.getDescription() + ", " + description;
  }
}
```

```java
Beverage beverage = new Espresso();
System.out.println(beverage);

beverage = new Mocha(beverage);
System.out.println(beverage);
```
![decorator_1.svg](/design_pattern/images/decorator_1.svg)
===
## 팩토리 패턴
- 팩토리 패턴은 구상 클래스를 생성하는 역할을 한다.
- 구상 클래스는 실제 기능을 제공하는 클래스이며, 팩토리 패턴을 통해 이러한 클래스의 인스턴스를 생성할 수 있다.
- 이를 통해 객체 생성 로직이 클라이언트 코드와 분리되어, 객체 생성의 변경이 필요할 때 클라이언트 코드를 수정하지 않고 팩토리 클래스만 수정하면 된다.

### 팩토리 메서드 패턴
- 객체 생성의 책임을 서브클래스에게 위임하는 패턴 
- 즉, “객체를 직접 new로 생성하지 않고, 하위 클래스에서 구체 객체를 결정”하게 하는 방법
- 장점: 클라이언트는 구체 클래스를 몰라도 됨 (결합도↓)
- 유형: 한 종류의 제품군(Product 계열)을 다룰 때 유용
- 예시: java.util.Calendar.getInstance()
```java
public abstract class PizzaStore{

  public Pizza orderPizza(String type){
    Pizza pizza;

    pizza = createPizza(type);

    pizza.prepare();
    pizza.bake();
    pizza.cut();
    pizza.box();

    return pizza;
  }

  abstract Pizza createPizza(String type); // 팩토리 메소드가 PizzaStore의 추상 메소드로 바뀌었다. 
}

public class NYPizzaStore extends PizzaStore{

  @Override
  public Pizza createPizza(String item){
    if(item.equals("cheese")) return new NYStyleCheesePizza();
    if(item.equals("peperoni")) return new NYStylePepperoniPizza();
    if(item.equals("clam")) return new NYStyleClamPizza();
    if(item.equals("veggie")) return new NYStyleVeggiePizza();
    return null;
  }
}


public class ChicagoPizzaStore extends PizzaStore{

  @Override
  public Pizza createPizza(String item){
    if(item.equals("cheese")) return new ChicagoStyleCheesePizza();
    if(item.equals("peper")) return new ChicagoStylePepperoniPizza();
    if(item.equals("clam")) return new ChicagoStyleClamPizza();
    if(item.equals("veggie")) return new ChicagoStyleVeggiePizza();
    return null;
  }
}
```

```java
public class PizzaTestDrive {	
    public static void main(String[] args) {		
        PizzaStore nyStore = new NYPizzaStore();		
        PizzaStore chicagoStore = new ChicagoPizzaStore();	
        
        Pizza pizza = nyStore.orderPizza("cheese");		
        System.out.println(pizza.getname());		
        
        pizza = chicagoStore.orderPizza("cheese");		
        System.out.println(pizza.getname());	
    } 
}
```
### 추상 팩토리 메서드 패턴
- 서로 관련된 여러 객체를 일관된 방식으로 생성하는 인터페이스를 제공하는 패턴
- 즉, 제품군(Product family) 을 통째로 생성할 때 사용
- 장점: 제품군 간의 호환성 유지
- 유형: 제품군을 다룰 때 유용 (버튼+입력창+체크박스 등)
- 예시: JDBC Connection, Statement, ResultSet 등을 하나의 드라이버 팩토리가 제공하는 구조
```java
public interface PizzaIngredientFactory {	
    public Dough createDough();	
    public Sauce createSauce();	
    public Cheese createCheese();	
    public Veggies[] createVeggies();	
    public Pepperoni createPepperoni();	
    public Clams createClams(); 
}

public class NYPizzaingredientFactory implements PizzaIngredientFactory{	
    @Override	
    public Dough createDough() {		
    	return new ThinCrustdough();	
    }	

    @Override	
    public Sauce createSauce() {		
    	return new MarinaraSauce();	
    }	

    @Override	
    public Cheese createCheese() {		
    	return new ReggianoCheese();	
    }	

    @Override	
    public Veggies[] createVeggies() {		
    	Veggies veggies[] = { new Farlic(), new Onion(), new Mushroom(), new RedPepper() };		
    	return veggies;	
    }	

    @Override	
    public Pepperoni createPepperoni() {		
    	return new SlicedPepperoni();	
    }	

    @Override	
    public Clams createClams() {		
    	return new Freshclams();	
    } 
}
```
```java
public abstract class Pizza{	
    String name;	
    
    Dough dough;	
    Sauce sauce;	
    Veggies veggies[];	
    Cheese cheese;	
    Pepperoni pepperoni;	
    Clams clams;		

    abstract void prepare(); //추상 메소드로 변경됨	

    //기타 메소드
}
public class CheesePizza extends Pizza{	
    PizzaIngredientFactory ingredientFactory;	
    
    public CheesePizza(PizzaIngredientFactory ingredientFactory) {		
    	this.ingredientFactory = ingredientFactory;	
    }	

    @Override	
    public void prepare() {		
        this.dough = ingredientFactory.createDough();		
        this.sauce = ingredientFactory.createSauce();		
        this.cheese = ingredientFactory.createCheese();	
    } 
}
```
```java
public class NYPizzaStore extends PizzaStore{	

    @Override	
    public Pizza createPizza(String type){		
        Pizza pizza = null;		
        PizzaIngredientFactory ingredientFactory = new NYPizzaingredientFactory();		

        if(type.equals("cheese")){			
        	pizza = new CheesePizza(ingredientFactory);			
        	pizza.setName(ingredientFactory.NY_STYLE+" Cheese Pizza");		
        }else if(type.equals("peper")){			
        	pizza = new PepperoniPizza(ingredientFactory);			
        	pizza.setName(ingredientFactory.NY_STYLE+" Pepperoni Pizza");		
        }		
        return pizza;	
    } 
}
```

---
## 싱글턴 패턴
* 클래스 인스턴스를 하나 만들고, 그 인스턴스로의 전역 접근을 제공하는 패턴
* 하나의 인스턴스를 사용하기 때문에 동기화 문제 주의해야 함
* 개인적으로 Spring 사용하면 직접 이 패턴을 사용하기보다 스프링 Bean을 사용하면 된다고 봐서 알고만 있는 패턴.
```java
public class Singleton {
  // 클래스 로딩 시점에 인스턴스를 생성
  private static final Singleton uniqueInstance = new Singleton();

  // private 생성자: 외부에서 인스턴스 생성 불가
  private Singleton() {}

  // 이미 생성된 인스턴스를 반환
  public static Singleton getInstance() {
    return uniqueInstance;
  }
} 
```

---
## 커맨드 패턴
* 명령을 캡슐화하는 패턴
* 캡슐화된 명령을 구체화하는 클래스는, 그 명령을 수행하는 클래스를 입력받아(전략?) 사용함.
* 구성요소
  * Receiver: 실제로 일하는 객체
  * Command: 명령 객체. Receiver를 받아 실행
  * Invoker: 명령을 실행하는 객체. Command만 알지 어떻게 실행되는지 모름
  * Client: 조립하는 곳
* Invoker은 Receiver를 모르기에 그냥 command를 호출해서 실행하기만 함. 어떻게 동작하는지 모름.
  * → 나중에 실행 방법을 바꾸고 싶을 때 Invoker는 안 건드리고 Command 객체만 교체하면 된다는 장점
  * → 함수가 아니라 객체여서 실행 시점을 지연할 수 있음.

![command_pattenr_1.png](/design_pattern/images/command_pattenr_1.png)
**Command 인터페이스**
```java
public interface Command {
  void execute();
}
```
**Receiver 객체**
```java
public class Light {
  public void on() {
    System.out.println("불이 켜졌습니다.");
  }

  public void off() {
    System.out.println("불이 꺼졌습니다.");
  }
}
```
**명령 객체**
```java
public class LightOnCommand implements Command {

  private final Light light;

  public LightOnCommand(Light light) {
    this.light = light;
  }

  @Override
  public void execute() {
    light.on();   // Receiver에게 실제 작업 위임
  }
}
```
**Invoker 객체: 명령을 실행하는 쪽**
```java
public class RemoteController {

    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void pressButton() {
        command.execute();   // 실제 수행 내용은 모름
    }
}
```
**Client: 조립하는 곳**
```java
public class Client {

    public static void main(String[] args) {

        // Receiver
        Light light = new Light();

        // Command 생성
        Command lightOn = new LightOnCommand(light);
        Command lightOff = new LightOffCommand(light);

        // Invoker
        RemoteController remote = new RemoteController();

        // 불 켜기
        remote.setCommand(lightOn);
        remote.pressButton();

        // 불 끄기
        remote.setCommand(lightOff);
        remote.pressButton();
    }
}
```
> **전략패턴과 커맨드 패턴의 차이**
> * **전략패턴**은 하나의 작업을 어떤 알고리즘으로 하느냐를 바꾸는거고
> * **커맨드패턴**은 요청이 어떤걸로 바뀌느냐(on()이면 버튼을 누르는게 실행되냐, 불을 키는게 실행되냐)를 바꾸는거임. 
> * "어떻게"는 전략패턴, "무엇을"은 커맨드패턴.
## 어댑터 패턴
## 템플릿 메서드 패턴
## 반복자 패턴
## 컴포지트 패턴
## 상태 패턴
## 프록시 패턴

