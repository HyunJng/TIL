# Docker 기초
## 목차
* [1. 도커 학습 전 기초지식](#1-도커-학습-전-기초지식)
    + [1.1. 컨테이너형 가상화](#11-컨테이너형-가상화)
    + [1.2. 컨테이너의 장점](#12-컨테이너의-장점)
* [2. Docker 개념](#2-Docker-개념)
    + [2.1. 도커란?](#21-도커란?)
    + [2.2. 도커를 왜 사용?](#22-도커를-왜-사용)
    + [2.3. 도커컴포즈란?](#23-도커컴포즈란)
    + [2.4. 쿠버네티스란?](#24-쿠버네티스란)
    + [2.5. 컨테이너 이미지란?](#25-컨테이너-이미지란)
* [3. 도커 이미지](#3-도커-이미지)
    + [3.1. 이미지 생성하는 Dockerfile 문법](#31-이미지-생성하는-Dockerfile-문법)
    + [3.2. 이미지 관련 명령어](#32-이미지-관련-명령어)
        - [3.2.1. 이미지 빌드 명령어](#321-이미지-빌드-명령어)
        - [3.2.2. 이미지 가져오기 명령어](#322-이미지-가져오기-명령어)
        - [3.2.3. 이미지 목록 확인 명령어](#323-이미지-목록-확인-명령어)
        - [3.2.4. 이미지 태그 지정](#324-이미지-태그-지정)
        - [3.2.5. 사용않는 이미지 한번에 파기](#325-사용않는-이미지-한번에-파기)
    + [3.3. 이미지 만들때 고려사항](#33-이미지-만들때-고려사항)
* [4. 도커 컨테이너](#4-도커-컨테이너)
    * [4.1. 컨테이너 라이프사이클](#41-컨테이너-라이프사이클)
    * [4.2. 컨테이너 관련 명령어](#42-컨테이너-관련-명령어)
        * [4.2.1. 컨테이너 실행](#421-컨테이너-실행)
        * [4.2.2. 컨테이너 목록](#422-컨테이너-목록)
        * [4.2.3. 컨테이너 중지](#423-컨테이너-중지)
        * [4.2.4. 컨테이너 파기](#424-컨테이너-파기)
        * [4.2.5. 실행중인 컨테이너에서 커맨드 실행](#425-실행중인-컨테이너에서-커맨드-실행)
        * [4.2.6. 컨테이너와 호스트간 파일 복사](#426-컨테이너와-호스트간-파일-복사)
        * [4.2.7. 중지상태 컨테이너 한번에 파기](#427-중지상태-컨테이너-한번에-파기)
* [5. 도커 컴포즈](#5-도커-컴포즈)
    * [5.1. 도커 컴포즈 필요성](#51-도커-컴포즈-필요성)
    * [5.2. 도커 컴포즈 `.yml`파일 문법 설명](#52-도커-컴포즈-yml파일-문법-설명)
    * [5.3. 도커 컴포즈 관련 명령어](#53-도커-컴포즈-관련-명령어)
        * [5.3.1. 도커 컴포즈 설정 파일 실행](#531-도커-컴포즈-설정-파일-실행)
        * [5.3.2. 도커 컴포즈 설정 파일 내리기](#532-도커-컴포즈-설정-파일-내리기)
* [6. 컨테이너의 이식성](#6-컨테이너의-이식성)
    * [6.1. BuildKit](#61-BuildKit)
    * [6.2. Multi-stage build](#62-Multi-stage-build)
## 1. 도커 학습 전 기초지식
### 1.1. 컨테이너형 가상화
![docker_basic_1.png](/docker/images/docker_basic_1.png)
- **컨테이너**
    - 호스트 OS에서 파일 시스템을 나누고 
새로운 파일 시스템과 애플리케이션으로 구성된 별도의 공간

![docker_basic_2.png](/docker/images%2Fdocker_basic_2.png)
- 컨테이너 가상화 기술
    - OS커널은 호스트껄 사용하고, 단순히 파일 시스템을 분리하는거라 빠른 시작과 종료가 가능하다

> **호스트 OS형 가상화** 
>
> 가상화처럼 OS에 설치한 가상화 소프트웨어로 하드웨어를 구현해 게스트 OS를 만드는 것 

### 1.2. 컨테이너의 장점
- 기존 가상 머신에 비해 성능 오버헤드가 적음 
- 빠르고 쉬운 애플리케이션 배포 
- 이미지 버젼 관리과 쉬움 
- 각 컨테이너 사이에 독립적인 동작 환경 제공

---

## 2. Docker 개념
### 2.1. 도커란?
![docker_basic_3.png](/docker/images%2Fdocker_basic_3.png)
컨테이너 가상화 도구로 세 개의 구성으로 되어있다
- Docker Server : 컨테이너 가상화 기술 구현한 기본 애플리케이션
- Docker Rest API: 도커 서버를 조작하기 위한 인터페이스
- Docker CLI: 도커 커맨드 라인 애플리케이션으로, 도커 REST API와 통신하여 대화식으로 도커 서버를 조작할 수 있다

### 2.2. 도커를 왜 사용?
`애플리케이션 + 파일시스템(OS환경 + 미들웨어)`를 한꺼번에 패키징으로 배포할 수 있기 때문에 
이식성이 높고, 환경을 코드로 관리할 수 있어 공유가 편함

### 2.3. 도커컴포즈란?
- yml형식의 설정 파일에 실행할 컨테이너를 정의하거나 의존관계를 정의하여 동작 순서를 제어하는 컨테이너 오케스트레이션 시스템이다.
- 애플리케이션 미들웨어의 의존성을 코드로 간단히 구현할 수 있다.

### 2.4. 쿠버네티스란?
- 여러 컨테이너를 한꺼번에 관리할 수 있게 해주는 컨테이너 오케스트레이션 시스템이다.

### 2.5. 컨테이너 이미지란?
- **컨테이너**: 컨테이너 이미지 기반으로 구성된, 파일 시스템과 애플리케이션이 실행된 상태
- **컨테이너 이미지**: 컨테이너를 구성하는 파일 시스템과 실행 애플리케이션 설정을 모은 템플릿

---
## 3. 도커 이미지
### 3.1. 이미지 생성하는 Dockerfile 문법
> Dockerfile
>    - 도커가 어떤 이미지를 생성하고 실행할지를 정의하는 파일 
>    - Dockerfile 에서 사용하는 키워드를 인스트럭션(instruction) 이라고 한다

**예시**
```shell
## 호스트
~/works/test
├─cronjob
│  └─Dockerfile
│  └─cron-example
│  └─task.sh
```
```shell
## Dockerfile
FROM ubuntu:23.18

RUN apt update
RUN apt install -y cron

COPY task.sh /usr/local/bin
COPY cron-example /etc/cron.d
RUN chmod 0644 /etc/cron.d/cron-example

CMD ["cron", "-f"]
```

#### `FROM`
컨텡이너 기본 이미지 지정. 이미지 빌드할 때 먼저 `FROM`으로 지정한 이미지 다운하고 실행

#### `WORKDIR`
컨테이너 내 현재 디렉토리 지정. 지정된 경로가 없으면 새로 만듬

#### `COPY`
```shell
COPY [from(호스트 파일 경로)] [to(컨테이너 파일 경로)]
```
호스트에서 컨테이너 내로 복사할 파일 지정

#### `RUN`
이미지를 빌드할 때 컨테이너에서 실행하는 커맨드 정의. 
보통 도구의 설치나 애플리케이션의 빌드 처리를 기술함

#### `CMD`
```shell
## go run main.go 실행
CMD ["go", "run", "main.go"]
```
컨테이너를 실행할 때 컨테이너에서 실행할 프로세스를 지정. `RUN`과 달리 `CMD`는 컨테이너 시작 시 한번 실행된다. 보통 CMD로 애플리케이션 자체를 동작시킨다.
명령어가 하나만 존재해야한다.(여러개면 마지막꺼 실행)

#### `ENV`
도커 컨테이너에서 사용할 수 있는 환경변수를 지정

#### `ARG`
이미지 빌드시에만 사용할 수 있는 임시변수

### 3.2. 이미지 관련 명령어
#### 3.2.1. 이미지 빌드 명령어
```shell
docker image build -t 이미지명[:태그명] Dockerfile의_디렉토리_경로
```
- 이미지명은 네임스페이스를 지정해주는 것을 추천
- 태그를 지정하지 않으면 기본적으로 `:latest`가 된다.(기존건 none)
- 기본적으로 `Dockerfile`이름의 파일을 찾는다(확장자 없음)

```shell
## -f 파일이름: Dockerfile 이름 외의 도커파일을 사용하고 싶을 때 
docker image build -f Dockerfile-test -t test/dockerImage:latest . 

## --pull: 도커기본이미지를 저장해둔걸 사용하지 않고 새로 가져옴
docker image build --pull=true -t test/dockerImage:latest . 
```

#### 3.2.2. 이미지 가져오기 명령어
```shell
docker image pull [option] 리포지터리명[:태그명]
docker image pull nginx:latest
```
- 가져온 이미지는 그대로 컨테이너로 사용할 수 있다 

#### 3.2.3. 이미지 목록 확인 명령어
```shell
docker image ls
```

#### 3.2.4. 이미지 태그 지정
```shell
docker image tag 기존이미지명[:태그] 새이미지명[:태그]
docker image tag test/dockerImage:latest test/dockerImage:1.0.0
```
#### 3.2.5. 사용않는 이미지 한번에 파기
```shell
docker image prune 
```
### 3.3. 이미지 만들때 고려사항
> "하나의 컨테이너는 **하나의 관심사**에만 집중해야한다"

하나의 컨테이너에 하나의 프로세스만 존재하도록 두라는 말이 아니다. 
하나의 이미지에 여러 프로세스가 존재하도록 만들어도 된다.(cron job과 process를 하나의 이미지로 만들 수 있듯)
그러나 관심사는 하나로 두어야한다. (nginx 컨테이너로 리버스 프록세의 관심사에 집중하고, 웹애플리케이션 프로세스 컨테이너는 따로 둠)

---

## 4. 도커 컨테이너
### 4.1. 컨테이너 라이프사이클
- 실행
- 중지: 컨테이너 종료 시 상태는 유지된다. 따라서 중지된 컨테이너를 재실행할 수 있다.
- 파기: 디스크 용량을 위해 사용않는 중지된 컨테이너를 파기할 수 있다.

### 4.2. 컨테이너 관련 명령어 
#### 4.2.1. 컨테이너 실행
```shell
docker container run [컨테이너 이미지] [컨테이너에서 실행할 커맨드]
docker container run ubuntu:23.18 uname -a

## --name 이름 : 이름 지정
docker container run --name testImage1 ubuntu:23.18 uname -a // testImage1로 컨테이너 이름 지정

## -p : 포트포워딩(host: 9000, container:8080)
docker container run --name testImage1 -p 9000:8080 ubuntu:23.18 uname -a // testImage1로 컨테이너 이름 지정

## -d : 백그라운드 실행
docker container run -d test:latest

## -it: 쉘 진입
docker container run -it ubuntu:23.18

## --rm: 컨테이너 종료시 자동 파기
docker container run --rm test:latest
```

#### 4.2.2. 컨테이너 목록
```shell
docker container ls [옵션]

## --filter : 특정 조건만 확인
docker container ls --filter "ancestor=test:latest" # 이미지가 test:latest 인 컨테이너 검색

## -a : 중지한 컨테이너를 포함한 모든 컨테이너 확잉ㄴ
docker container ls -a
```

#### 4.2.3. 컨테이너 중지
```shell
docker container stop [컨테이너 이름 | 컨테이너 ID]
```

#### 4.2.4. 컨테이너 파기
```shell
docker container rm [컨테이너 이름 | 컨테이너 ID]
```

#### 4.2.5. 실행중인 컨테이너에서 커맨드 실행
```shell
docker container exec [컨테이너 이름 | 컨테이너 ID] [커맨드]
docker container exec tester pwd
```

#### 4.2.6. 컨테이너와 호스트간 파일 복사
```shell
docker container cp [옵션] [컨테이너 이름 | 컨테이너 ID]:컨테이너_내_경로 호스트_내_경로
docker container cp [옵션] 호스트_내_경로 [컨테이너 이름 | 컨테이너 ID]:컨테이너_내_경로
```

#### 4.2.7. 중지상태 컨테이너 한번에 파기
```shell
docker container prune 
```

----
## 5. 도커 컴포즈
### 5.1. 도커 컴포즈 필요성
하나의 애플리케이션은 다른 애플리케이션과 통신하며 동작한다. 
컨테이너를 하나의 애플리케이션이라고 생각했을 때 컨테이너 간 서로 통신하고 의존성을 갖게 된다.

도커 컴포즈는 컨테이너 간 동작 제어를 위한 설정 파일이나 
환경 변수의 제공괴 의존관계, 포트포워딩과 같은 요소를 한번에 괸리할 수 있는 도구다.

### 5.2. 도커 컴포즈 `.yml`파일 문법 설명
```yml
version: "3.9"                # 파일 포맷 버전

services:
    echo:                     # 컨테이너 이름
        image: test:latest    # 컨테이너 이미지
        ports:                # 포트 포워딩
            - 9000:8080
    nginx:
        build: ./nginx        # 컴포즈 실행 시 해당 경로(호스트)의 Dockerfile 빌드하여 이미지 생성 후 실행 
        depends_on: echo      # 컨테이너 간 통신을 위해 echo 컨테이너 의존성 추가
        ports:                
            - 9001:8000
```

### 5.3. 도커 컴포즈 관련 명령어
#### 5.3.1. 도커 컴포즈 설정 파일 실행
```shell
docker compose up -d
```

#### 5.3.2. 도커 컴포즈 설정 파일 내리기
```shell
docker compose down
```

## 6. 컨테이너의 이식성
### 6.1. BuildKit
컨테이너형 가상화 기술은 호스트 OS와 리소스를 공유하므로, 
컨테이너가 실행할 수 있는 호스트는 CPU와 OS에 영향받을 수 밖에 없다.
> 어떤 CPU에서도 동작할 수 있도록 돕는 빌드 도구가 **BuildKit**이다. 

### 6.2. Multi-stage build
| 정적링크                | 동적 링크                     |
|---------------------|---------------------------|
| 빌드시 바이너리에 라이브러리가 링크 | 실행 시 라이브러리를 링크            |
| 바이너리 파일 사이즈가 커지기 쉬움 | OS에 필요한 라이브러리가 없으면 실행이 안됨 |
- 동적 링크면 호스트에선 동작하던 애플리케이션이 컨테이너에선 동작하지 않을 수 있음
- 되도록 정적 링크로 동작하도록 구현하면 되지만 그러면 바이너리 파일 크기가 커짐
> 빌드용 컨테이너와 실행용 컨테이너를 분리하고 
> 다양한 빌드용 도구로 실행용 컨테이너의 사이즈가 커지는 것을 예방하는 방법이 **Multi-stae build** 이다 

